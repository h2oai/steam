// GENERATED BY crudgen; DON'T EDIT

package data

import (
	"database/sql"
	"log"
	"time"

	"github.com/fatih/color"
	"github.com/pkg/errors"
	"gopkg.in/doug-martin/goqu.v3"
)

var debug bool

// ---------- -------------- ----------
// ---------- -------------- ----------
// ---------- Authentication ----------
// ---------- -------------- ----------
// ---------- -------------- ----------

func (ds *Datastore) CreateAuthentication(key, value string, options ...QueryOpt) (int64, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return 0, errors.Wrap(err, "beginning transaction")
	}

	var id int64
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, CreateOp, "authentication", nil)
		// Default insert fields
		authentication := goqu.Record{
			"key":   key,
			"value": value,
		}
		q.AddFields(authentication)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if debug {
			color.Set(color.FgGreen)
			log.Println(q.dataset.ToInsertSql(q.fields))
			color.Unset()
		}
		// Execute query
		res, err := q.dataset.Insert(q.fields).Exec()
		if err != nil {
			return errors.Wrap(err, "executing query")
		}
		id, err = res.LastInsertId()
		if err != nil {
			return errors.Wrap(err, "retrieving id")
		}
		q.entityId = id
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}

		return nil
	})

	return id, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) ReadAuthentications(options ...QueryOpt) ([]Authentication, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return []Authentication{}, errors.Wrap(err, "beginning transaction")
	}

	var authentications []Authentication
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, "", "authentication", nil)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if debug {
			color.Set(color.FgBlue)
			log.Println(q.dataset.ToSql())
			color.Unset()
		}
		// Execute query
		rows, err := getRows(tx, q.dataset)
		if err != nil {
			return err
		}
		defer rows.Close()
		authentications, err = ScanAuthentications(rows)
		if err != nil {
			return err
		}
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}

		return nil
	})

	return authentications, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) ReadAuthentication(options ...QueryOpt) (Authentication, bool, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return Authentication{}, false, errors.Wrap(err, "beginning transaction")
	}

	var authentication Authentication
	var exists bool
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, "", "authentication", nil)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if debug {
			color.Set(color.FgBlue)
			log.Println(q.dataset.ToSql())
			color.Unset()
		}
		// Execute query
		row, err := getRow(tx, q.dataset)
		if err != nil {
			return err
		}
		authentication, err = ScanAuthentication(row)
		if err == sql.ErrNoRows {
			return nil
		} else if err == nil {
			exists = true
		}
		if err != nil {
			return err
		}
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}

		return nil
	})

	return authentication, exists, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) UpdateAuthentication(authenticationId int64, options ...QueryOpt) error {
	tx, err := ds.db.Begin()
	if err != nil {
		return errors.Wrap(err, "beginning transaction")
	}

	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, UpdateOp, "authentication", authenticationId)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if debug && len(q.fields) > 0 {
			color.Set(color.FgYellow)
			log.Println(q.dataset.ToUpdateSql(q.fields))
			color.Unset()
		}
		// Execute query
		if len(q.fields) > 0 {
			if _, err := q.dataset.Update(q.fields).Exec(); err != nil {
				return errors.Wrap(err, "executing query")
			}
		}
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}
		return nil
	})

	return errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) DeleteAuthentication(authenticationId int64, options ...QueryOpt) error {
	tx, err := ds.db.Begin()
	if err != nil {
		return errors.Wrap(err, "beginning transaction")
	}

	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, DeleteOp, "authentication", authenticationId)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if debug {
			color.Set(color.FgRed)
			log.Println(q.dataset.ToDeleteSql())
			color.Unset()
		}
		// Execute query
		if _, err := q.dataset.Delete().Exec(); err != nil {
			return errors.Wrap(err, "executing query")
		}
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}

		return errors.Wrap(deletePrivilege(tx, ByEntityId(q.entityId), ByEntityType(q.entityType)), "deleting privileges")
	})

	return errors.Wrap(err, "committing transaction")
}
func createAuthentication(tx *goqu.TxDatabase, key, value string, options ...QueryOpt) (int64, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, CreateOp, "authentication", nil)
	// Default insert fields
	authentication := goqu.Record{
		"key":   key,
		"value": value,
	}
	q.AddFields(authentication)
	for _, option := range options {
		if err := option(q); err != nil {
			return 0, errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgGreen)
		log.Println(q.dataset.ToInsertSql(q.fields))
		color.Unset()
	}
	// Execute query
	res, err := q.dataset.Insert(q.fields).Exec()
	if err != nil {
		return 0, errors.Wrap(err, "executing query")
	}
	id, err := res.LastInsertId()
	if err != nil {
		return 0, errors.Wrap(err, "retrieving id")
	}
	q.entityId = id
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return 0, errors.Wrap(err, "running post functions")
		}
	}

	return id, nil
}

func readAuthentications(tx *goqu.TxDatabase, options ...QueryOpt) ([]Authentication, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "", "authentication", nil)
	for _, option := range options {
		if err := option(q); err != nil {
			return []Authentication{}, errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgBlue)
		log.Println(q.dataset.ToSql())
		color.Unset()
	}
	// Execute query
	rows, err := getRows(tx, q.dataset)
	if err != nil {
		return []Authentication{}, err
	}
	defer rows.Close()
	authentications, err := ScanAuthentications(rows)
	if err != nil {
		return []Authentication{}, err
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return []Authentication{}, errors.Wrap(err, "running post functions")
		}
	}

	// Scan rows to Authentications
	return authentications, nil
}

func readAuthentication(tx *goqu.TxDatabase, options ...QueryOpt) (Authentication, bool, error) {
	var exists bool
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "", "authentication", nil)
	for _, option := range options {
		if err := option(q); err != nil {
			return Authentication{}, exists, errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgBlue)
		log.Println(q.dataset.ToSql())
		color.Unset()
	}
	// Execute query
	row, err := getRow(tx, q.dataset)
	if err != nil {
		return Authentication{}, false, err
	}
	ret_authentication, err := ScanAuthentication(row)
	if err == sql.ErrNoRows {
		return Authentication{}, false, nil
	} else if err == nil {
		exists = true
	} else {
		return Authentication{}, false, err
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return Authentication{}, false, errors.Wrap(err, "running post functions")
		}
	}
	// Scan row to Authentication
	return ret_authentication, exists, nil
}

func updateAuthentication(tx *goqu.TxDatabase, authenticationId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, UpdateOp, "authentication", authenticationId)
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if debug && len(q.fields) > 0 {
		color.Set(color.FgYellow)
		log.Println(q.dataset.ToUpdateSql(q.fields))
		color.Unset()
	}
	// Execute query
	if len(q.fields) > 0 {
		if _, err := q.dataset.Update(q.fields).Exec(); err != nil {
			return errors.Wrap(err, "executing query")
		}
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}
	return nil
}

func deleteAuthentication(tx *goqu.TxDatabase, authenticationId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, DeleteOp, "authentication", authenticationId)
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgRed)
		log.Println(q.dataset.ToDeleteSql())
		color.Unset()
	}
	// Execute query
	if _, err := q.dataset.Delete().Exec(); err != nil {
		return errors.Wrap(err, "executing query")
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}

	return nil

}

// ---------- ------------- ----------
// ---------- ------------- ----------
// ---------- binomialModel ----------
// ---------- ------------- ----------
// ---------- ------------- ----------

func createBinomialModel(tx *goqu.TxDatabase, modelId int64, mse, rSquared, logloss, auc, gini float64, options ...QueryOpt) (int64, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, CreateOp, "binomial_model", nil)
	// Default insert fields
	binomialModel := goqu.Record{
		"model_id":  modelId,
		"mse":       mse,
		"r_squared": rSquared,
		"logloss":   logloss,
		"auc":       auc,
		"gini":      gini,
	}
	q.AddFields(binomialModel)
	for _, option := range options {
		if err := option(q); err != nil {
			return 0, errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgGreen)
		log.Println(q.dataset.ToInsertSql(q.fields))
		color.Unset()
	}
	// Execute query
	res, err := q.dataset.Insert(q.fields).Exec()
	if err != nil {
		return 0, errors.Wrap(err, "executing query")
	}
	id, err := res.LastInsertId()
	if err != nil {
		return 0, errors.Wrap(err, "retrieving id")
	}
	q.entityId = id
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return 0, errors.Wrap(err, "running post functions")
		}
	}

	return id, nil
}

func readBinomialModels(tx *goqu.TxDatabase, options ...QueryOpt) ([]binomialModel, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "", "binomial_model", nil)
	for _, option := range options {
		if err := option(q); err != nil {
			return []binomialModel{}, errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgBlue)
		log.Println(q.dataset.ToSql())
		color.Unset()
	}
	// Execute query
	rows, err := getRows(tx, q.dataset)
	if err != nil {
		return []binomialModel{}, err
	}
	defer rows.Close()
	binomialModels, err := ScanBinomialModels(rows)
	if err != nil {
		return []binomialModel{}, err
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return []binomialModel{}, errors.Wrap(err, "running post functions")
		}
	}

	// Scan rows to binomialModels
	return binomialModels, nil
}

func readBinomialModel(tx *goqu.TxDatabase, options ...QueryOpt) (binomialModel, bool, error) {
	var exists bool
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "", "binomial_model", nil)
	for _, option := range options {
		if err := option(q); err != nil {
			return binomialModel{}, exists, errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgBlue)
		log.Println(q.dataset.ToSql())
		color.Unset()
	}
	// Execute query
	row, err := getRow(tx, q.dataset)
	if err != nil {
		return binomialModel{}, false, err
	}
	ret_binomialModel, err := ScanBinomialModel(row)
	if err == sql.ErrNoRows {
		return binomialModel{}, false, nil
	} else if err == nil {
		exists = true
	} else {
		return binomialModel{}, false, err
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return binomialModel{}, false, errors.Wrap(err, "running post functions")
		}
	}
	// Scan row to binomialModel
	return ret_binomialModel, exists, nil
}

func updateBinomialModel(tx *goqu.TxDatabase, binomialModelId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, UpdateOp, "binomial_model", binomialModelId)
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if debug && len(q.fields) > 0 {
		color.Set(color.FgYellow)
		log.Println(q.dataset.ToUpdateSql(q.fields))
		color.Unset()
	}
	// Execute query
	if len(q.fields) > 0 {
		if _, err := q.dataset.Update(q.fields).Exec(); err != nil {
			return errors.Wrap(err, "executing query")
		}
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}
	return nil
}

func deleteBinomialModel(tx *goqu.TxDatabase, binomialModelId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, DeleteOp, "binomial_model", binomialModelId)
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgRed)
		log.Println(q.dataset.ToDeleteSql())
		color.Unset()
	}
	// Execute query
	if _, err := q.dataset.Delete().Exec(); err != nil {
		return errors.Wrap(err, "executing query")
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}

	return nil

}

// ---------- ------- ----------
// ---------- ------- ----------
// ---------- Cluster ----------
// ---------- ------- ----------
// ---------- ------- ----------

func (ds *Datastore) CreateCluster(name string, clusterTypeId int64, options ...QueryOpt) (int64, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return 0, errors.Wrap(err, "beginning transaction")
	}

	var id int64
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, CreateOp, "cluster", nil)
		// Default insert fields
		cluster := goqu.Record{
			"name":    name,
			"type_id": clusterTypeId,
			"state":   States.Starting,
			"created": time.Now(),
		}
		q.AddFields(cluster)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if debug {
			color.Set(color.FgGreen)
			log.Println(q.dataset.ToInsertSql(q.fields))
			color.Unset()
		}
		// Execute query
		res, err := q.dataset.Insert(q.fields).Exec()
		if err != nil {
			return errors.Wrap(err, "executing query")
		}
		id, err = res.LastInsertId()
		if err != nil {
			return errors.Wrap(err, "retrieving id")
		}
		q.entityId = id
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}

		return nil
	})

	return id, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) ReadClusters(options ...QueryOpt) ([]Cluster, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return []Cluster{}, errors.Wrap(err, "beginning transaction")
	}

	var clusters []Cluster
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, "", "cluster", nil)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if debug {
			color.Set(color.FgBlue)
			log.Println(q.dataset.ToSql())
			color.Unset()
		}
		// Execute query
		rows, err := getRows(tx, q.dataset)
		if err != nil {
			return err
		}
		defer rows.Close()
		clusters, err = ScanClusters(rows)
		if err != nil {
			return err
		}
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}

		return nil
	})

	return clusters, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) ReadCluster(options ...QueryOpt) (Cluster, bool, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return Cluster{}, false, errors.Wrap(err, "beginning transaction")
	}

	var cluster Cluster
	var exists bool
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, "", "cluster", nil)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if debug {
			color.Set(color.FgBlue)
			log.Println(q.dataset.ToSql())
			color.Unset()
		}
		// Execute query
		row, err := getRow(tx, q.dataset)
		if err != nil {
			return err
		}
		cluster, err = ScanCluster(row)
		if err == sql.ErrNoRows {
			return nil
		} else if err == nil {
			exists = true
		}
		if err != nil {
			return err
		}
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}

		return nil
	})

	return cluster, exists, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) UpdateCluster(clusterId int64, options ...QueryOpt) error {
	tx, err := ds.db.Begin()
	if err != nil {
		return errors.Wrap(err, "beginning transaction")
	}

	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, UpdateOp, "cluster", clusterId)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if debug && len(q.fields) > 0 {
			color.Set(color.FgYellow)
			log.Println(q.dataset.ToUpdateSql(q.fields))
			color.Unset()
		}
		// Execute query
		if len(q.fields) > 0 {
			if _, err := q.dataset.Update(q.fields).Exec(); err != nil {
				return errors.Wrap(err, "executing query")
			}
		}
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}
		return nil
	})

	return errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) DeleteCluster(clusterId int64, options ...QueryOpt) error {
	tx, err := ds.db.Begin()
	if err != nil {
		return errors.Wrap(err, "beginning transaction")
	}

	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, DeleteOp, "cluster", clusterId)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if debug {
			color.Set(color.FgRed)
			log.Println(q.dataset.ToDeleteSql())
			color.Unset()
		}
		// Execute query
		if _, err := q.dataset.Delete().Exec(); err != nil {
			return errors.Wrap(err, "executing query")
		}
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}

		return errors.Wrap(deletePrivilege(tx, ByEntityId(q.entityId), ByEntityType(q.entityType)), "deleting privileges")
	})

	return errors.Wrap(err, "committing transaction")
}
func createCluster(tx *goqu.TxDatabase, name string, clusterTypeId int64, options ...QueryOpt) (int64, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, CreateOp, "cluster", nil)
	// Default insert fields
	cluster := goqu.Record{
		"name":    name,
		"type_id": clusterTypeId,
		"state":   States.Starting,
		"created": time.Now(),
	}
	q.AddFields(cluster)
	for _, option := range options {
		if err := option(q); err != nil {
			return 0, errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgGreen)
		log.Println(q.dataset.ToInsertSql(q.fields))
		color.Unset()
	}
	// Execute query
	res, err := q.dataset.Insert(q.fields).Exec()
	if err != nil {
		return 0, errors.Wrap(err, "executing query")
	}
	id, err := res.LastInsertId()
	if err != nil {
		return 0, errors.Wrap(err, "retrieving id")
	}
	q.entityId = id
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return 0, errors.Wrap(err, "running post functions")
		}
	}

	return id, nil
}

func readClusters(tx *goqu.TxDatabase, options ...QueryOpt) ([]Cluster, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "", "cluster", nil)
	for _, option := range options {
		if err := option(q); err != nil {
			return []Cluster{}, errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgBlue)
		log.Println(q.dataset.ToSql())
		color.Unset()
	}
	// Execute query
	rows, err := getRows(tx, q.dataset)
	if err != nil {
		return []Cluster{}, err
	}
	defer rows.Close()
	clusters, err := ScanClusters(rows)
	if err != nil {
		return []Cluster{}, err
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return []Cluster{}, errors.Wrap(err, "running post functions")
		}
	}

	// Scan rows to Clusters
	return clusters, nil
}

func readCluster(tx *goqu.TxDatabase, options ...QueryOpt) (Cluster, bool, error) {
	var exists bool
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "", "cluster", nil)
	for _, option := range options {
		if err := option(q); err != nil {
			return Cluster{}, exists, errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgBlue)
		log.Println(q.dataset.ToSql())
		color.Unset()
	}
	// Execute query
	row, err := getRow(tx, q.dataset)
	if err != nil {
		return Cluster{}, false, err
	}
	ret_cluster, err := ScanCluster(row)
	if err == sql.ErrNoRows {
		return Cluster{}, false, nil
	} else if err == nil {
		exists = true
	} else {
		return Cluster{}, false, err
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return Cluster{}, false, errors.Wrap(err, "running post functions")
		}
	}
	// Scan row to Cluster
	return ret_cluster, exists, nil
}

func updateCluster(tx *goqu.TxDatabase, clusterId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, UpdateOp, "cluster", clusterId)
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if debug && len(q.fields) > 0 {
		color.Set(color.FgYellow)
		log.Println(q.dataset.ToUpdateSql(q.fields))
		color.Unset()
	}
	// Execute query
	if len(q.fields) > 0 {
		if _, err := q.dataset.Update(q.fields).Exec(); err != nil {
			return errors.Wrap(err, "executing query")
		}
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}
	return nil
}

func deleteCluster(tx *goqu.TxDatabase, clusterId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, DeleteOp, "cluster", clusterId)
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgRed)
		log.Println(q.dataset.ToDeleteSql())
		color.Unset()
	}
	// Execute query
	if _, err := q.dataset.Delete().Exec(); err != nil {
		return errors.Wrap(err, "executing query")
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}

	return nil

}

// ---------- ----------- ----------
// ---------- ----------- ----------
// ---------- clusterType ----------
// ---------- ----------- ----------
// ---------- ----------- ----------

func createClusterType(tx *goqu.TxDatabase, name string, options ...QueryOpt) (int64, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, CreateOp, "cluster_type", nil)
	// Default insert fields
	clusterType := goqu.Record{
		"name": name,
	}
	q.AddFields(clusterType)
	for _, option := range options {
		if err := option(q); err != nil {
			return 0, errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgGreen)
		log.Println(q.dataset.ToInsertSql(q.fields))
		color.Unset()
	}
	// Execute query
	res, err := q.dataset.Insert(q.fields).Exec()
	if err != nil {
		return 0, errors.Wrap(err, "executing query")
	}
	id, err := res.LastInsertId()
	if err != nil {
		return 0, errors.Wrap(err, "retrieving id")
	}
	q.entityId = id
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return 0, errors.Wrap(err, "running post functions")
		}
	}

	return id, nil
}

func readClusterTypes(tx *goqu.TxDatabase, options ...QueryOpt) ([]clusterType, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "", "cluster_type", nil)
	for _, option := range options {
		if err := option(q); err != nil {
			return []clusterType{}, errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgBlue)
		log.Println(q.dataset.ToSql())
		color.Unset()
	}
	// Execute query
	rows, err := getRows(tx, q.dataset)
	if err != nil {
		return []clusterType{}, err
	}
	defer rows.Close()
	clusterTypes, err := ScanClusterTypes(rows)
	if err != nil {
		return []clusterType{}, err
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return []clusterType{}, errors.Wrap(err, "running post functions")
		}
	}

	// Scan rows to clusterTypes
	return clusterTypes, nil
}

func readClusterType(tx *goqu.TxDatabase, options ...QueryOpt) (clusterType, bool, error) {
	var exists bool
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "", "cluster_type", nil)
	for _, option := range options {
		if err := option(q); err != nil {
			return clusterType{}, exists, errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgBlue)
		log.Println(q.dataset.ToSql())
		color.Unset()
	}
	// Execute query
	row, err := getRow(tx, q.dataset)
	if err != nil {
		return clusterType{}, false, err
	}
	ret_clusterType, err := ScanClusterType(row)
	if err == sql.ErrNoRows {
		return clusterType{}, false, nil
	} else if err == nil {
		exists = true
	} else {
		return clusterType{}, false, err
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return clusterType{}, false, errors.Wrap(err, "running post functions")
		}
	}
	// Scan row to clusterType
	return ret_clusterType, exists, nil
}

func updateClusterType(tx *goqu.TxDatabase, clusterTypeId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, UpdateOp, "cluster_type", clusterTypeId)
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if debug && len(q.fields) > 0 {
		color.Set(color.FgYellow)
		log.Println(q.dataset.ToUpdateSql(q.fields))
		color.Unset()
	}
	// Execute query
	if len(q.fields) > 0 {
		if _, err := q.dataset.Update(q.fields).Exec(); err != nil {
			return errors.Wrap(err, "executing query")
		}
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}
	return nil
}

func deleteClusterType(tx *goqu.TxDatabase, clusterTypeId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, DeleteOp, "cluster_type", clusterTypeId)
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgRed)
		log.Println(q.dataset.ToDeleteSql())
		color.Unset()
	}
	// Execute query
	if _, err := q.dataset.Delete().Exec(); err != nil {
		return errors.Wrap(err, "executing query")
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}

	return nil

}

// ---------- ----------------- ----------
// ---------- ----------------- ----------
// ---------- ClusterYarnDetail ----------
// ---------- ----------------- ----------
// ---------- ----------------- ----------

func (ds *Datastore) CreateClusterYarnDetail(engineId, size int64, applicationId, memory, outputDir string, options ...QueryOpt) (int64, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return 0, errors.Wrap(err, "beginning transaction")
	}

	var id int64
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, CreateOp, "cluster_yarn_detail", nil)
		// Default insert fields
		clusterYarnDetail := goqu.Record{
			"engine_id":      engineId,
			"size":           size,
			"application_id": applicationId,
			"memory":         memory,
			"output_dir":     outputDir,
		}
		q.AddFields(clusterYarnDetail)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if debug {
			color.Set(color.FgGreen)
			log.Println(q.dataset.ToInsertSql(q.fields))
			color.Unset()
		}
		// Execute query
		res, err := q.dataset.Insert(q.fields).Exec()
		if err != nil {
			return errors.Wrap(err, "executing query")
		}
		id, err = res.LastInsertId()
		if err != nil {
			return errors.Wrap(err, "retrieving id")
		}
		q.entityId = id
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}

		return nil
	})

	return id, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) ReadClusterYarnDetails(options ...QueryOpt) ([]ClusterYarnDetail, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return []ClusterYarnDetail{}, errors.Wrap(err, "beginning transaction")
	}

	var clusterYarnDetails []ClusterYarnDetail
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, "", "cluster_yarn_detail", nil)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if debug {
			color.Set(color.FgBlue)
			log.Println(q.dataset.ToSql())
			color.Unset()
		}
		// Execute query
		rows, err := getRows(tx, q.dataset)
		if err != nil {
			return err
		}
		defer rows.Close()
		clusterYarnDetails, err = ScanClusterYarnDetails(rows)
		if err != nil {
			return err
		}
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}

		return nil
	})

	return clusterYarnDetails, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) ReadClusterYarnDetail(options ...QueryOpt) (ClusterYarnDetail, bool, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return ClusterYarnDetail{}, false, errors.Wrap(err, "beginning transaction")
	}

	var clusterYarnDetail ClusterYarnDetail
	var exists bool
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, "", "cluster_yarn_detail", nil)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if debug {
			color.Set(color.FgBlue)
			log.Println(q.dataset.ToSql())
			color.Unset()
		}
		// Execute query
		row, err := getRow(tx, q.dataset)
		if err != nil {
			return err
		}
		clusterYarnDetail, err = ScanClusterYarnDetail(row)
		if err == sql.ErrNoRows {
			return nil
		} else if err == nil {
			exists = true
		}
		if err != nil {
			return err
		}
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}

		return nil
	})

	return clusterYarnDetail, exists, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) UpdateClusterYarnDetail(clusterYarnDetailId int64, options ...QueryOpt) error {
	tx, err := ds.db.Begin()
	if err != nil {
		return errors.Wrap(err, "beginning transaction")
	}

	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, UpdateOp, "cluster_yarn_detail", clusterYarnDetailId)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if debug && len(q.fields) > 0 {
			color.Set(color.FgYellow)
			log.Println(q.dataset.ToUpdateSql(q.fields))
			color.Unset()
		}
		// Execute query
		if len(q.fields) > 0 {
			if _, err := q.dataset.Update(q.fields).Exec(); err != nil {
				return errors.Wrap(err, "executing query")
			}
		}
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}
		return nil
	})

	return errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) DeleteClusterYarnDetail(clusterYarnDetailId int64, options ...QueryOpt) error {
	tx, err := ds.db.Begin()
	if err != nil {
		return errors.Wrap(err, "beginning transaction")
	}

	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, DeleteOp, "cluster_yarn_detail", clusterYarnDetailId)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if debug {
			color.Set(color.FgRed)
			log.Println(q.dataset.ToDeleteSql())
			color.Unset()
		}
		// Execute query
		if _, err := q.dataset.Delete().Exec(); err != nil {
			return errors.Wrap(err, "executing query")
		}
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}

		return errors.Wrap(deletePrivilege(tx, ByEntityId(q.entityId), ByEntityType(q.entityType)), "deleting privileges")
	})

	return errors.Wrap(err, "committing transaction")
}
func createClusterYarnDetail(tx *goqu.TxDatabase, engineId, size int64, applicationId, memory, outputDir string, options ...QueryOpt) (int64, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, CreateOp, "cluster_yarn_detail", nil)
	// Default insert fields
	clusterYarnDetail := goqu.Record{
		"engine_id":      engineId,
		"size":           size,
		"application_id": applicationId,
		"memory":         memory,
		"output_dir":     outputDir,
	}
	q.AddFields(clusterYarnDetail)
	for _, option := range options {
		if err := option(q); err != nil {
			return 0, errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgGreen)
		log.Println(q.dataset.ToInsertSql(q.fields))
		color.Unset()
	}
	// Execute query
	res, err := q.dataset.Insert(q.fields).Exec()
	if err != nil {
		return 0, errors.Wrap(err, "executing query")
	}
	id, err := res.LastInsertId()
	if err != nil {
		return 0, errors.Wrap(err, "retrieving id")
	}
	q.entityId = id
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return 0, errors.Wrap(err, "running post functions")
		}
	}

	return id, nil
}

func readClusterYarnDetails(tx *goqu.TxDatabase, options ...QueryOpt) ([]ClusterYarnDetail, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "", "cluster_yarn_detail", nil)
	for _, option := range options {
		if err := option(q); err != nil {
			return []ClusterYarnDetail{}, errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgBlue)
		log.Println(q.dataset.ToSql())
		color.Unset()
	}
	// Execute query
	rows, err := getRows(tx, q.dataset)
	if err != nil {
		return []ClusterYarnDetail{}, err
	}
	defer rows.Close()
	clusterYarnDetails, err := ScanClusterYarnDetails(rows)
	if err != nil {
		return []ClusterYarnDetail{}, err
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return []ClusterYarnDetail{}, errors.Wrap(err, "running post functions")
		}
	}

	// Scan rows to ClusterYarnDetails
	return clusterYarnDetails, nil
}

func readClusterYarnDetail(tx *goqu.TxDatabase, options ...QueryOpt) (ClusterYarnDetail, bool, error) {
	var exists bool
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "", "cluster_yarn_detail", nil)
	for _, option := range options {
		if err := option(q); err != nil {
			return ClusterYarnDetail{}, exists, errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgBlue)
		log.Println(q.dataset.ToSql())
		color.Unset()
	}
	// Execute query
	row, err := getRow(tx, q.dataset)
	if err != nil {
		return ClusterYarnDetail{}, false, err
	}
	ret_clusterYarnDetail, err := ScanClusterYarnDetail(row)
	if err == sql.ErrNoRows {
		return ClusterYarnDetail{}, false, nil
	} else if err == nil {
		exists = true
	} else {
		return ClusterYarnDetail{}, false, err
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return ClusterYarnDetail{}, false, errors.Wrap(err, "running post functions")
		}
	}
	// Scan row to ClusterYarnDetail
	return ret_clusterYarnDetail, exists, nil
}

func updateClusterYarnDetail(tx *goqu.TxDatabase, clusterYarnDetailId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, UpdateOp, "cluster_yarn_detail", clusterYarnDetailId)
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if debug && len(q.fields) > 0 {
		color.Set(color.FgYellow)
		log.Println(q.dataset.ToUpdateSql(q.fields))
		color.Unset()
	}
	// Execute query
	if len(q.fields) > 0 {
		if _, err := q.dataset.Update(q.fields).Exec(); err != nil {
			return errors.Wrap(err, "executing query")
		}
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}
	return nil
}

func deleteClusterYarnDetail(tx *goqu.TxDatabase, clusterYarnDetailId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, DeleteOp, "cluster_yarn_detail", clusterYarnDetailId)
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgRed)
		log.Println(q.dataset.ToDeleteSql())
		color.Unset()
	}
	// Execute query
	if _, err := q.dataset.Delete().Exec(); err != nil {
		return errors.Wrap(err, "executing query")
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}

	return nil

}

// ---------- ------ ----------
// ---------- ------ ----------
// ---------- Engine ----------
// ---------- ------ ----------
// ---------- ------ ----------

func (ds *Datastore) CreateEngine(name, location string, options ...QueryOpt) (int64, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return 0, errors.Wrap(err, "beginning transaction")
	}

	var id int64
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, CreateOp, "engine", nil)
		// Default insert fields
		engine := goqu.Record{
			"name":     name,
			"location": location,
			"created":  time.Now(),
		}
		q.AddFields(engine)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if debug {
			color.Set(color.FgGreen)
			log.Println(q.dataset.ToInsertSql(q.fields))
			color.Unset()
		}
		// Execute query
		res, err := q.dataset.Insert(q.fields).Exec()
		if err != nil {
			return errors.Wrap(err, "executing query")
		}
		id, err = res.LastInsertId()
		if err != nil {
			return errors.Wrap(err, "retrieving id")
		}
		q.entityId = id
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}

		return nil
	})

	return id, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) ReadEngines(options ...QueryOpt) ([]Engine, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return []Engine{}, errors.Wrap(err, "beginning transaction")
	}

	var engines []Engine
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, "", "engine", nil)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if debug {
			color.Set(color.FgBlue)
			log.Println(q.dataset.ToSql())
			color.Unset()
		}
		// Execute query
		rows, err := getRows(tx, q.dataset)
		if err != nil {
			return err
		}
		defer rows.Close()
		engines, err = ScanEngines(rows)
		if err != nil {
			return err
		}
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}

		return nil
	})

	return engines, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) ReadEngine(options ...QueryOpt) (Engine, bool, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return Engine{}, false, errors.Wrap(err, "beginning transaction")
	}

	var engine Engine
	var exists bool
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, "", "engine", nil)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if debug {
			color.Set(color.FgBlue)
			log.Println(q.dataset.ToSql())
			color.Unset()
		}
		// Execute query
		row, err := getRow(tx, q.dataset)
		if err != nil {
			return err
		}
		engine, err = ScanEngine(row)
		if err == sql.ErrNoRows {
			return nil
		} else if err == nil {
			exists = true
		}
		if err != nil {
			return err
		}
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}

		return nil
	})

	return engine, exists, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) UpdateEngine(engineId int64, options ...QueryOpt) error {
	tx, err := ds.db.Begin()
	if err != nil {
		return errors.Wrap(err, "beginning transaction")
	}

	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, UpdateOp, "engine", engineId)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if debug && len(q.fields) > 0 {
			color.Set(color.FgYellow)
			log.Println(q.dataset.ToUpdateSql(q.fields))
			color.Unset()
		}
		// Execute query
		if len(q.fields) > 0 {
			if _, err := q.dataset.Update(q.fields).Exec(); err != nil {
				return errors.Wrap(err, "executing query")
			}
		}
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}
		return nil
	})

	return errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) DeleteEngine(engineId int64, options ...QueryOpt) error {
	tx, err := ds.db.Begin()
	if err != nil {
		return errors.Wrap(err, "beginning transaction")
	}

	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, DeleteOp, "engine", engineId)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if debug {
			color.Set(color.FgRed)
			log.Println(q.dataset.ToDeleteSql())
			color.Unset()
		}
		// Execute query
		if _, err := q.dataset.Delete().Exec(); err != nil {
			return errors.Wrap(err, "executing query")
		}
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}

		return errors.Wrap(deletePrivilege(tx, ByEntityId(q.entityId), ByEntityType(q.entityType)), "deleting privileges")
	})

	return errors.Wrap(err, "committing transaction")
}
func createEngine(tx *goqu.TxDatabase, name, location string, options ...QueryOpt) (int64, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, CreateOp, "engine", nil)
	// Default insert fields
	engine := goqu.Record{
		"name":     name,
		"location": location,
		"created":  time.Now(),
	}
	q.AddFields(engine)
	for _, option := range options {
		if err := option(q); err != nil {
			return 0, errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgGreen)
		log.Println(q.dataset.ToInsertSql(q.fields))
		color.Unset()
	}
	// Execute query
	res, err := q.dataset.Insert(q.fields).Exec()
	if err != nil {
		return 0, errors.Wrap(err, "executing query")
	}
	id, err := res.LastInsertId()
	if err != nil {
		return 0, errors.Wrap(err, "retrieving id")
	}
	q.entityId = id
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return 0, errors.Wrap(err, "running post functions")
		}
	}

	return id, nil
}

func readEngines(tx *goqu.TxDatabase, options ...QueryOpt) ([]Engine, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "", "engine", nil)
	for _, option := range options {
		if err := option(q); err != nil {
			return []Engine{}, errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgBlue)
		log.Println(q.dataset.ToSql())
		color.Unset()
	}
	// Execute query
	rows, err := getRows(tx, q.dataset)
	if err != nil {
		return []Engine{}, err
	}
	defer rows.Close()
	engines, err := ScanEngines(rows)
	if err != nil {
		return []Engine{}, err
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return []Engine{}, errors.Wrap(err, "running post functions")
		}
	}

	// Scan rows to Engines
	return engines, nil
}

func readEngine(tx *goqu.TxDatabase, options ...QueryOpt) (Engine, bool, error) {
	var exists bool
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "", "engine", nil)
	for _, option := range options {
		if err := option(q); err != nil {
			return Engine{}, exists, errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgBlue)
		log.Println(q.dataset.ToSql())
		color.Unset()
	}
	// Execute query
	row, err := getRow(tx, q.dataset)
	if err != nil {
		return Engine{}, false, err
	}
	ret_engine, err := ScanEngine(row)
	if err == sql.ErrNoRows {
		return Engine{}, false, nil
	} else if err == nil {
		exists = true
	} else {
		return Engine{}, false, err
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return Engine{}, false, errors.Wrap(err, "running post functions")
		}
	}
	// Scan row to Engine
	return ret_engine, exists, nil
}

func updateEngine(tx *goqu.TxDatabase, engineId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, UpdateOp, "engine", engineId)
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if debug && len(q.fields) > 0 {
		color.Set(color.FgYellow)
		log.Println(q.dataset.ToUpdateSql(q.fields))
		color.Unset()
	}
	// Execute query
	if len(q.fields) > 0 {
		if _, err := q.dataset.Update(q.fields).Exec(); err != nil {
			return errors.Wrap(err, "executing query")
		}
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}
	return nil
}

func deleteEngine(tx *goqu.TxDatabase, engineId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, DeleteOp, "engine", engineId)
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgRed)
		log.Println(q.dataset.ToDeleteSql())
		color.Unset()
	}
	// Execute query
	if _, err := q.dataset.Delete().Exec(); err != nil {
		return errors.Wrap(err, "executing query")
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}

	return nil

}

// ---------- ---------- ----------
// ---------- ---------- ----------
// ---------- entityType ----------
// ---------- ---------- ----------
// ---------- ---------- ----------

func createEntityType(tx *goqu.TxDatabase, name string, options ...QueryOpt) (int64, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, CreateOp, "entity_type", nil)
	// Default insert fields
	entityType := goqu.Record{
		"name": name,
	}
	q.AddFields(entityType)
	for _, option := range options {
		if err := option(q); err != nil {
			return 0, errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgGreen)
		log.Println(q.dataset.ToInsertSql(q.fields))
		color.Unset()
	}
	// Execute query
	res, err := q.dataset.Insert(q.fields).Exec()
	if err != nil {
		return 0, errors.Wrap(err, "executing query")
	}
	id, err := res.LastInsertId()
	if err != nil {
		return 0, errors.Wrap(err, "retrieving id")
	}
	q.entityId = id
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return 0, errors.Wrap(err, "running post functions")
		}
	}

	return id, nil
}

func readEntityTypes(tx *goqu.TxDatabase, options ...QueryOpt) ([]entityType, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "", "entity_type", nil)
	for _, option := range options {
		if err := option(q); err != nil {
			return []entityType{}, errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgBlue)
		log.Println(q.dataset.ToSql())
		color.Unset()
	}
	// Execute query
	rows, err := getRows(tx, q.dataset)
	if err != nil {
		return []entityType{}, err
	}
	defer rows.Close()
	entityTypes, err := ScanEntityTypes(rows)
	if err != nil {
		return []entityType{}, err
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return []entityType{}, errors.Wrap(err, "running post functions")
		}
	}

	// Scan rows to entityTypes
	return entityTypes, nil
}

func readEntityType(tx *goqu.TxDatabase, options ...QueryOpt) (entityType, bool, error) {
	var exists bool
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "", "entity_type", nil)
	for _, option := range options {
		if err := option(q); err != nil {
			return entityType{}, exists, errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgBlue)
		log.Println(q.dataset.ToSql())
		color.Unset()
	}
	// Execute query
	row, err := getRow(tx, q.dataset)
	if err != nil {
		return entityType{}, false, err
	}
	ret_entityType, err := ScanEntityType(row)
	if err == sql.ErrNoRows {
		return entityType{}, false, nil
	} else if err == nil {
		exists = true
	} else {
		return entityType{}, false, err
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return entityType{}, false, errors.Wrap(err, "running post functions")
		}
	}
	// Scan row to entityType
	return ret_entityType, exists, nil
}

func updateEntityType(tx *goqu.TxDatabase, entityTypeId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, UpdateOp, "entity_type", entityTypeId)
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if debug && len(q.fields) > 0 {
		color.Set(color.FgYellow)
		log.Println(q.dataset.ToUpdateSql(q.fields))
		color.Unset()
	}
	// Execute query
	if len(q.fields) > 0 {
		if _, err := q.dataset.Update(q.fields).Exec(); err != nil {
			return errors.Wrap(err, "executing query")
		}
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}
	return nil
}

func deleteEntityType(tx *goqu.TxDatabase, entityTypeId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, DeleteOp, "entity_type", entityTypeId)
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgRed)
		log.Println(q.dataset.ToDeleteSql())
		color.Unset()
	}
	// Execute query
	if _, err := q.dataset.Delete().Exec(); err != nil {
		return errors.Wrap(err, "executing query")
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}

	return nil

}

// ---------- ------- ----------
// ---------- ------- ----------
// ---------- History ----------
// ---------- ------- ----------
// ---------- ------- ----------

func (ds *Datastore) CreateHistory(action string, identityId int64, entityType string, entityId int64, options ...QueryOpt) (int64, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return 0, errors.Wrap(err, "beginning transaction")
	}

	var id int64
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, CreateOp, "history", nil)
		// Default insert fields
		history := goqu.Record{
			"action":      action,
			"identity_id": identityId,
			"entity_type": entityType,
			"entity_id":   entityId,
			"created":     time.Now(),
		}
		q.AddFields(history)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if debug {
			color.Set(color.FgGreen)
			log.Println(q.dataset.ToInsertSql(q.fields))
			color.Unset()
		}
		// Execute query
		res, err := q.dataset.Insert(q.fields).Exec()
		if err != nil {
			return errors.Wrap(err, "executing query")
		}
		id, err = res.LastInsertId()
		if err != nil {
			return errors.Wrap(err, "retrieving id")
		}
		q.entityId = id
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}

		return nil
	})

	return id, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) ReadHistories(options ...QueryOpt) ([]History, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return []History{}, errors.Wrap(err, "beginning transaction")
	}

	var histories []History
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, "", "history", nil)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if debug {
			color.Set(color.FgBlue)
			log.Println(q.dataset.ToSql())
			color.Unset()
		}
		// Execute query
		rows, err := getRows(tx, q.dataset)
		if err != nil {
			return err
		}
		defer rows.Close()
		histories, err = ScanHistorys(rows)
		if err != nil {
			return err
		}
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}

		return nil
	})

	return histories, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) ReadHistory(options ...QueryOpt) (History, bool, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return History{}, false, errors.Wrap(err, "beginning transaction")
	}

	var history History
	var exists bool
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, "", "history", nil)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if debug {
			color.Set(color.FgBlue)
			log.Println(q.dataset.ToSql())
			color.Unset()
		}
		// Execute query
		row, err := getRow(tx, q.dataset)
		if err != nil {
			return err
		}
		history, err = ScanHistory(row)
		if err == sql.ErrNoRows {
			return nil
		} else if err == nil {
			exists = true
		}
		if err != nil {
			return err
		}
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}

		return nil
	})

	return history, exists, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) UpdateHistory(historyId int64, options ...QueryOpt) error {
	tx, err := ds.db.Begin()
	if err != nil {
		return errors.Wrap(err, "beginning transaction")
	}

	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, UpdateOp, "history", historyId)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if debug && len(q.fields) > 0 {
			color.Set(color.FgYellow)
			log.Println(q.dataset.ToUpdateSql(q.fields))
			color.Unset()
		}
		// Execute query
		if len(q.fields) > 0 {
			if _, err := q.dataset.Update(q.fields).Exec(); err != nil {
				return errors.Wrap(err, "executing query")
			}
		}
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}
		return nil
	})

	return errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) DeleteHistory(historyId int64, options ...QueryOpt) error {
	tx, err := ds.db.Begin()
	if err != nil {
		return errors.Wrap(err, "beginning transaction")
	}

	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, DeleteOp, "history", historyId)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if debug {
			color.Set(color.FgRed)
			log.Println(q.dataset.ToDeleteSql())
			color.Unset()
		}
		// Execute query
		if _, err := q.dataset.Delete().Exec(); err != nil {
			return errors.Wrap(err, "executing query")
		}
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}

		return errors.Wrap(deletePrivilege(tx, ByEntityId(q.entityId), ByEntityType(q.entityType)), "deleting privileges")
	})

	return errors.Wrap(err, "committing transaction")
}
func createHistory(tx *goqu.TxDatabase, action string, identityId int64, entityType string, entityId int64, options ...QueryOpt) (int64, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, CreateOp, "history", nil)
	// Default insert fields
	history := goqu.Record{
		"action":      action,
		"identity_id": identityId,
		"entity_type": entityType,
		"entity_id":   entityId,
		"created":     time.Now(),
	}
	q.AddFields(history)
	for _, option := range options {
		if err := option(q); err != nil {
			return 0, errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgGreen)
		log.Println(q.dataset.ToInsertSql(q.fields))
		color.Unset()
	}
	// Execute query
	res, err := q.dataset.Insert(q.fields).Exec()
	if err != nil {
		return 0, errors.Wrap(err, "executing query")
	}
	id, err := res.LastInsertId()
	if err != nil {
		return 0, errors.Wrap(err, "retrieving id")
	}
	q.entityId = id
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return 0, errors.Wrap(err, "running post functions")
		}
	}

	return id, nil
}

func readHistories(tx *goqu.TxDatabase, options ...QueryOpt) ([]History, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "", "history", nil)
	for _, option := range options {
		if err := option(q); err != nil {
			return []History{}, errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgBlue)
		log.Println(q.dataset.ToSql())
		color.Unset()
	}
	// Execute query
	rows, err := getRows(tx, q.dataset)
	if err != nil {
		return []History{}, err
	}
	defer rows.Close()
	histories, err := ScanHistorys(rows)
	if err != nil {
		return []History{}, err
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return []History{}, errors.Wrap(err, "running post functions")
		}
	}

	// Scan rows to Histories
	return histories, nil
}

func readHistory(tx *goqu.TxDatabase, options ...QueryOpt) (History, bool, error) {
	var exists bool
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "", "history", nil)
	for _, option := range options {
		if err := option(q); err != nil {
			return History{}, exists, errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgBlue)
		log.Println(q.dataset.ToSql())
		color.Unset()
	}
	// Execute query
	row, err := getRow(tx, q.dataset)
	if err != nil {
		return History{}, false, err
	}
	ret_history, err := ScanHistory(row)
	if err == sql.ErrNoRows {
		return History{}, false, nil
	} else if err == nil {
		exists = true
	} else {
		return History{}, false, err
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return History{}, false, errors.Wrap(err, "running post functions")
		}
	}
	// Scan row to History
	return ret_history, exists, nil
}

func updateHistory(tx *goqu.TxDatabase, historyId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, UpdateOp, "history", historyId)
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if debug && len(q.fields) > 0 {
		color.Set(color.FgYellow)
		log.Println(q.dataset.ToUpdateSql(q.fields))
		color.Unset()
	}
	// Execute query
	if len(q.fields) > 0 {
		if _, err := q.dataset.Update(q.fields).Exec(); err != nil {
			return errors.Wrap(err, "executing query")
		}
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}
	return nil
}

func deleteHistory(tx *goqu.TxDatabase, historyId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, DeleteOp, "history", historyId)
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgRed)
		log.Println(q.dataset.ToDeleteSql())
		color.Unset()
	}
	// Execute query
	if _, err := q.dataset.Delete().Exec(); err != nil {
		return errors.Wrap(err, "executing query")
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}

	return nil

}

// ---------- -------- ----------
// ---------- -------- ----------
// ---------- Identity ----------
// ---------- -------- ----------
// ---------- -------- ----------

func (ds *Datastore) CreateIdentity(name string, options ...QueryOpt) (int64, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return 0, errors.Wrap(err, "beginning transaction")
	}

	var id int64
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, CreateOp, "identity", nil)
		// Default insert fields
		identity := goqu.Record{
			"name":      name,
			"auth_type": LocalAuth,
			"is_active": 1,
			"created":   time.Now(),
		}
		q.AddFields(identity)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if debug {
			color.Set(color.FgGreen)
			log.Println(q.dataset.ToInsertSql(q.fields))
			color.Unset()
		}
		// Execute query
		res, err := q.dataset.Insert(q.fields).Exec()
		if err != nil {
			return errors.Wrap(err, "executing query")
		}
		id, err = res.LastInsertId()
		if err != nil {
			return errors.Wrap(err, "retrieving id")
		}
		q.entityId = id
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}

		return nil
	})

	return id, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) ReadIdentities(options ...QueryOpt) ([]Identity, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return []Identity{}, errors.Wrap(err, "beginning transaction")
	}

	var identities []Identity
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, "", "identity", nil)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if debug {
			color.Set(color.FgBlue)
			log.Println(q.dataset.ToSql())
			color.Unset()
		}
		// Execute query
		rows, err := getRows(tx, q.dataset)
		if err != nil {
			return err
		}
		defer rows.Close()
		identities, err = ScanIdentitys(rows)
		if err != nil {
			return err
		}
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}

		return nil
	})

	return identities, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) ReadIdentity(options ...QueryOpt) (Identity, bool, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return Identity{}, false, errors.Wrap(err, "beginning transaction")
	}

	var identity Identity
	var exists bool
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, "", "identity", nil)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if debug {
			color.Set(color.FgBlue)
			log.Println(q.dataset.ToSql())
			color.Unset()
		}
		// Execute query
		row, err := getRow(tx, q.dataset)
		if err != nil {
			return err
		}
		identity, err = ScanIdentity(row)
		if err == sql.ErrNoRows {
			return nil
		} else if err == nil {
			exists = true
		}
		if err != nil {
			return err
		}
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}

		return nil
	})

	return identity, exists, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) UpdateIdentity(identityId int64, options ...QueryOpt) error {
	tx, err := ds.db.Begin()
	if err != nil {
		return errors.Wrap(err, "beginning transaction")
	}

	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, UpdateOp, "identity", identityId)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if debug && len(q.fields) > 0 {
			color.Set(color.FgYellow)
			log.Println(q.dataset.ToUpdateSql(q.fields))
			color.Unset()
		}
		// Execute query
		if len(q.fields) > 0 {
			if _, err := q.dataset.Update(q.fields).Exec(); err != nil {
				return errors.Wrap(err, "executing query")
			}
		}
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}
		return nil
	})

	return errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) DeleteIdentity(identityId int64, options ...QueryOpt) error {
	tx, err := ds.db.Begin()
	if err != nil {
		return errors.Wrap(err, "beginning transaction")
	}

	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, DeleteOp, "identity", identityId)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if debug {
			color.Set(color.FgRed)
			log.Println(q.dataset.ToDeleteSql())
			color.Unset()
		}
		// Execute query
		if _, err := q.dataset.Delete().Exec(); err != nil {
			return errors.Wrap(err, "executing query")
		}
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}

		return errors.Wrap(deletePrivilege(tx, ByEntityId(q.entityId), ByEntityType(q.entityType)), "deleting privileges")
	})

	return errors.Wrap(err, "committing transaction")
}
func createIdentity(tx *goqu.TxDatabase, name string, options ...QueryOpt) (int64, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, CreateOp, "identity", nil)
	// Default insert fields
	identity := goqu.Record{
		"name":      name,
		"auth_type": LocalAuth,
		"is_active": 1,
		"created":   time.Now(),
	}
	q.AddFields(identity)
	for _, option := range options {
		if err := option(q); err != nil {
			return 0, errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgGreen)
		log.Println(q.dataset.ToInsertSql(q.fields))
		color.Unset()
	}
	// Execute query
	res, err := q.dataset.Insert(q.fields).Exec()
	if err != nil {
		return 0, errors.Wrap(err, "executing query")
	}
	id, err := res.LastInsertId()
	if err != nil {
		return 0, errors.Wrap(err, "retrieving id")
	}
	q.entityId = id
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return 0, errors.Wrap(err, "running post functions")
		}
	}

	return id, nil
}

func readIdentities(tx *goqu.TxDatabase, options ...QueryOpt) ([]Identity, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "", "identity", nil)
	for _, option := range options {
		if err := option(q); err != nil {
			return []Identity{}, errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgBlue)
		log.Println(q.dataset.ToSql())
		color.Unset()
	}
	// Execute query
	rows, err := getRows(tx, q.dataset)
	if err != nil {
		return []Identity{}, err
	}
	defer rows.Close()
	identities, err := ScanIdentitys(rows)
	if err != nil {
		return []Identity{}, err
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return []Identity{}, errors.Wrap(err, "running post functions")
		}
	}

	// Scan rows to Identities
	return identities, nil
}

func readIdentity(tx *goqu.TxDatabase, options ...QueryOpt) (Identity, bool, error) {
	var exists bool
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "", "identity", nil)
	for _, option := range options {
		if err := option(q); err != nil {
			return Identity{}, exists, errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgBlue)
		log.Println(q.dataset.ToSql())
		color.Unset()
	}
	// Execute query
	row, err := getRow(tx, q.dataset)
	if err != nil {
		return Identity{}, false, err
	}
	ret_identity, err := ScanIdentity(row)
	if err == sql.ErrNoRows {
		return Identity{}, false, nil
	} else if err == nil {
		exists = true
	} else {
		return Identity{}, false, err
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return Identity{}, false, errors.Wrap(err, "running post functions")
		}
	}
	// Scan row to Identity
	return ret_identity, exists, nil
}

func updateIdentity(tx *goqu.TxDatabase, identityId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, UpdateOp, "identity", identityId)
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if debug && len(q.fields) > 0 {
		color.Set(color.FgYellow)
		log.Println(q.dataset.ToUpdateSql(q.fields))
		color.Unset()
	}
	// Execute query
	if len(q.fields) > 0 {
		if _, err := q.dataset.Update(q.fields).Exec(); err != nil {
			return errors.Wrap(err, "executing query")
		}
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}
	return nil
}

func deleteIdentity(tx *goqu.TxDatabase, identityId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, DeleteOp, "identity", identityId)
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgRed)
		log.Println(q.dataset.ToDeleteSql())
		color.Unset()
	}
	// Execute query
	if _, err := q.dataset.Delete().Exec(); err != nil {
		return errors.Wrap(err, "executing query")
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}

	return nil

}

// ---------- ------------ ----------
// ---------- ------------ ----------
// ---------- identityRole ----------
// ---------- ------------ ----------
// ---------- ------------ ----------

func createIdentityRole(tx *goqu.TxDatabase, options ...QueryOpt) (int64, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, CreateOp, "identity_role", nil)
	// Default insert fields
	identityRole := goqu.Record{}
	q.AddFields(identityRole)
	for _, option := range options {
		if err := option(q); err != nil {
			return 0, errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgGreen)
		log.Println(q.dataset.ToInsertSql(q.fields))
		color.Unset()
	}
	// Execute query
	res, err := q.dataset.Insert(q.fields).Exec()
	if err != nil {
		return 0, errors.Wrap(err, "executing query")
	}
	id, err := res.LastInsertId()
	if err != nil {
		return 0, errors.Wrap(err, "retrieving id")
	}
	q.entityId = id
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return 0, errors.Wrap(err, "running post functions")
		}
	}

	return id, nil
}

func readIdentityRoles(tx *goqu.TxDatabase, options ...QueryOpt) ([]identityRole, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "", "identity_role", nil)
	for _, option := range options {
		if err := option(q); err != nil {
			return []identityRole{}, errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgBlue)
		log.Println(q.dataset.ToSql())
		color.Unset()
	}
	// Execute query
	rows, err := getRows(tx, q.dataset)
	if err != nil {
		return []identityRole{}, err
	}
	defer rows.Close()
	identityRoles, err := ScanIdentityRoles(rows)
	if err != nil {
		return []identityRole{}, err
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return []identityRole{}, errors.Wrap(err, "running post functions")
		}
	}

	// Scan rows to identityRoles
	return identityRoles, nil
}

func readIdentityRole(tx *goqu.TxDatabase, options ...QueryOpt) (identityRole, bool, error) {
	var exists bool
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "", "identity_role", nil)
	for _, option := range options {
		if err := option(q); err != nil {
			return identityRole{}, exists, errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgBlue)
		log.Println(q.dataset.ToSql())
		color.Unset()
	}
	// Execute query
	row, err := getRow(tx, q.dataset)
	if err != nil {
		return identityRole{}, false, err
	}
	ret_identityRole, err := ScanIdentityRole(row)
	if err == sql.ErrNoRows {
		return identityRole{}, false, nil
	} else if err == nil {
		exists = true
	} else {
		return identityRole{}, false, err
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return identityRole{}, false, errors.Wrap(err, "running post functions")
		}
	}
	// Scan row to identityRole
	return ret_identityRole, exists, nil
}

func updateIdentityRole(tx *goqu.TxDatabase, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, UpdateOp, "identity_role", nil)
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if debug && len(q.fields) > 0 {
		color.Set(color.FgYellow)
		log.Println(q.dataset.ToUpdateSql(q.fields))
		color.Unset()
	}
	// Execute query
	if len(q.fields) > 0 {
		if _, err := q.dataset.Update(q.fields).Exec(); err != nil {
			return errors.Wrap(err, "executing query")
		}
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}
	return nil
}

func deleteIdentityRole(tx *goqu.TxDatabase, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, DeleteOp, "identity_role", nil)
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgRed)
		log.Println(q.dataset.ToDeleteSql())
		color.Unset()
	}
	// Execute query
	if _, err := q.dataset.Delete().Exec(); err != nil {
		return errors.Wrap(err, "executing query")
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}

	return nil

}

// ---------- ----------------- ----------
// ---------- ----------------- ----------
// ---------- identityWorkgroup ----------
// ---------- ----------------- ----------
// ---------- ----------------- ----------

func createIdentityWorkgroup(tx *goqu.TxDatabase, identityId, workgroupId int64, options ...QueryOpt) (int64, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, CreateOp, "identity_workgroup", nil)
	// Default insert fields
	identityWorkgroup := goqu.Record{
		"identity_id":  identityId,
		"workgroup_id": workgroupId,
	}
	q.AddFields(identityWorkgroup)
	for _, option := range options {
		if err := option(q); err != nil {
			return 0, errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgGreen)
		log.Println(q.dataset.ToInsertSql(q.fields))
		color.Unset()
	}
	// Execute query
	res, err := q.dataset.Insert(q.fields).Exec()
	if err != nil {
		return 0, errors.Wrap(err, "executing query")
	}
	id, err := res.LastInsertId()
	if err != nil {
		return 0, errors.Wrap(err, "retrieving id")
	}
	q.entityId = id
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return 0, errors.Wrap(err, "running post functions")
		}
	}

	return id, nil
}

func readIdentityWorkgroups(tx *goqu.TxDatabase, options ...QueryOpt) ([]identityWorkgroup, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "", "identity_workgroup", nil)
	for _, option := range options {
		if err := option(q); err != nil {
			return []identityWorkgroup{}, errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgBlue)
		log.Println(q.dataset.ToSql())
		color.Unset()
	}
	// Execute query
	rows, err := getRows(tx, q.dataset)
	if err != nil {
		return []identityWorkgroup{}, err
	}
	defer rows.Close()
	identityWorkgroups, err := ScanIdentityWorkgroups(rows)
	if err != nil {
		return []identityWorkgroup{}, err
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return []identityWorkgroup{}, errors.Wrap(err, "running post functions")
		}
	}

	// Scan rows to identityWorkgroups
	return identityWorkgroups, nil
}

func readIdentityWorkgroup(tx *goqu.TxDatabase, options ...QueryOpt) (identityWorkgroup, bool, error) {
	var exists bool
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "", "identity_workgroup", nil)
	for _, option := range options {
		if err := option(q); err != nil {
			return identityWorkgroup{}, exists, errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgBlue)
		log.Println(q.dataset.ToSql())
		color.Unset()
	}
	// Execute query
	row, err := getRow(tx, q.dataset)
	if err != nil {
		return identityWorkgroup{}, false, err
	}
	ret_identityWorkgroup, err := ScanIdentityWorkgroup(row)
	if err == sql.ErrNoRows {
		return identityWorkgroup{}, false, nil
	} else if err == nil {
		exists = true
	} else {
		return identityWorkgroup{}, false, err
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return identityWorkgroup{}, false, errors.Wrap(err, "running post functions")
		}
	}
	// Scan row to identityWorkgroup
	return ret_identityWorkgroup, exists, nil
}

func updateIdentityWorkgroup(tx *goqu.TxDatabase, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, UpdateOp, "identity_workgroup", nil)
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if debug && len(q.fields) > 0 {
		color.Set(color.FgYellow)
		log.Println(q.dataset.ToUpdateSql(q.fields))
		color.Unset()
	}
	// Execute query
	if len(q.fields) > 0 {
		if _, err := q.dataset.Update(q.fields).Exec(); err != nil {
			return errors.Wrap(err, "executing query")
		}
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}
	return nil
}

func deleteIdentityWorkgroup(tx *goqu.TxDatabase, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, DeleteOp, "identity_workgroup", nil)
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgRed)
		log.Println(q.dataset.ToDeleteSql())
		color.Unset()
	}
	// Execute query
	if _, err := q.dataset.Delete().Exec(); err != nil {
		return errors.Wrap(err, "executing query")
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}

	return nil

}

// ---------- ----- ----------
// ---------- ----- ----------
// ---------- Label ----------
// ---------- ----- ----------
// ---------- ----- ----------

func (ds *Datastore) CreateLabel(projectId int64, name, description string, options ...QueryOpt) (int64, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return 0, errors.Wrap(err, "beginning transaction")
	}

	var id int64
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, CreateOp, "label", nil)
		// Default insert fields
		label := goqu.Record{
			"project_id":  projectId,
			"name":        name,
			"description": description,
			"created":     time.Now(),
		}
		q.AddFields(label)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if debug {
			color.Set(color.FgGreen)
			log.Println(q.dataset.ToInsertSql(q.fields))
			color.Unset()
		}
		// Execute query
		res, err := q.dataset.Insert(q.fields).Exec()
		if err != nil {
			return errors.Wrap(err, "executing query")
		}
		id, err = res.LastInsertId()
		if err != nil {
			return errors.Wrap(err, "retrieving id")
		}
		q.entityId = id
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}

		return nil
	})

	return id, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) ReadLabels(options ...QueryOpt) ([]Label, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return []Label{}, errors.Wrap(err, "beginning transaction")
	}

	var labels []Label
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, "", "label", nil)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if debug {
			color.Set(color.FgBlue)
			log.Println(q.dataset.ToSql())
			color.Unset()
		}
		// Execute query
		rows, err := getRows(tx, q.dataset)
		if err != nil {
			return err
		}
		defer rows.Close()
		labels, err = ScanLabels(rows)
		if err != nil {
			return err
		}
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}

		return nil
	})

	return labels, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) ReadLabel(options ...QueryOpt) (Label, bool, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return Label{}, false, errors.Wrap(err, "beginning transaction")
	}

	var label Label
	var exists bool
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, "", "label", nil)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if debug {
			color.Set(color.FgBlue)
			log.Println(q.dataset.ToSql())
			color.Unset()
		}
		// Execute query
		row, err := getRow(tx, q.dataset)
		if err != nil {
			return err
		}
		label, err = ScanLabel(row)
		if err == sql.ErrNoRows {
			return nil
		} else if err == nil {
			exists = true
		}
		if err != nil {
			return err
		}
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}

		return nil
	})

	return label, exists, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) UpdateLabel(labelId int64, options ...QueryOpt) error {
	tx, err := ds.db.Begin()
	if err != nil {
		return errors.Wrap(err, "beginning transaction")
	}

	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, UpdateOp, "label", labelId)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if debug && len(q.fields) > 0 {
			color.Set(color.FgYellow)
			log.Println(q.dataset.ToUpdateSql(q.fields))
			color.Unset()
		}
		// Execute query
		if len(q.fields) > 0 {
			if _, err := q.dataset.Update(q.fields).Exec(); err != nil {
				return errors.Wrap(err, "executing query")
			}
		}
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}
		return nil
	})

	return errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) DeleteLabel(labelId int64, options ...QueryOpt) error {
	tx, err := ds.db.Begin()
	if err != nil {
		return errors.Wrap(err, "beginning transaction")
	}

	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, DeleteOp, "label", labelId)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if debug {
			color.Set(color.FgRed)
			log.Println(q.dataset.ToDeleteSql())
			color.Unset()
		}
		// Execute query
		if _, err := q.dataset.Delete().Exec(); err != nil {
			return errors.Wrap(err, "executing query")
		}
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}

		return errors.Wrap(deletePrivilege(tx, ByEntityId(q.entityId), ByEntityType(q.entityType)), "deleting privileges")
	})

	return errors.Wrap(err, "committing transaction")
}
func createLabel(tx *goqu.TxDatabase, projectId int64, name, description string, options ...QueryOpt) (int64, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, CreateOp, "label", nil)
	// Default insert fields
	label := goqu.Record{
		"project_id":  projectId,
		"name":        name,
		"description": description,
		"created":     time.Now(),
	}
	q.AddFields(label)
	for _, option := range options {
		if err := option(q); err != nil {
			return 0, errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgGreen)
		log.Println(q.dataset.ToInsertSql(q.fields))
		color.Unset()
	}
	// Execute query
	res, err := q.dataset.Insert(q.fields).Exec()
	if err != nil {
		return 0, errors.Wrap(err, "executing query")
	}
	id, err := res.LastInsertId()
	if err != nil {
		return 0, errors.Wrap(err, "retrieving id")
	}
	q.entityId = id
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return 0, errors.Wrap(err, "running post functions")
		}
	}

	return id, nil
}

func readLabels(tx *goqu.TxDatabase, options ...QueryOpt) ([]Label, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "", "label", nil)
	for _, option := range options {
		if err := option(q); err != nil {
			return []Label{}, errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgBlue)
		log.Println(q.dataset.ToSql())
		color.Unset()
	}
	// Execute query
	rows, err := getRows(tx, q.dataset)
	if err != nil {
		return []Label{}, err
	}
	defer rows.Close()
	labels, err := ScanLabels(rows)
	if err != nil {
		return []Label{}, err
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return []Label{}, errors.Wrap(err, "running post functions")
		}
	}

	// Scan rows to Labels
	return labels, nil
}

func readLabel(tx *goqu.TxDatabase, options ...QueryOpt) (Label, bool, error) {
	var exists bool
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "", "label", nil)
	for _, option := range options {
		if err := option(q); err != nil {
			return Label{}, exists, errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgBlue)
		log.Println(q.dataset.ToSql())
		color.Unset()
	}
	// Execute query
	row, err := getRow(tx, q.dataset)
	if err != nil {
		return Label{}, false, err
	}
	ret_label, err := ScanLabel(row)
	if err == sql.ErrNoRows {
		return Label{}, false, nil
	} else if err == nil {
		exists = true
	} else {
		return Label{}, false, err
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return Label{}, false, errors.Wrap(err, "running post functions")
		}
	}
	// Scan row to Label
	return ret_label, exists, nil
}

func updateLabel(tx *goqu.TxDatabase, labelId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, UpdateOp, "label", labelId)
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if debug && len(q.fields) > 0 {
		color.Set(color.FgYellow)
		log.Println(q.dataset.ToUpdateSql(q.fields))
		color.Unset()
	}
	// Execute query
	if len(q.fields) > 0 {
		if _, err := q.dataset.Update(q.fields).Exec(); err != nil {
			return errors.Wrap(err, "executing query")
		}
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}
	return nil
}

func deleteLabel(tx *goqu.TxDatabase, labelId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, DeleteOp, "label", labelId)
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgRed)
		log.Println(q.dataset.ToDeleteSql())
		color.Unset()
	}
	// Execute query
	if _, err := q.dataset.Delete().Exec(); err != nil {
		return errors.Wrap(err, "executing query")
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}

	return nil

}

// ---------- ------ ----------
// ---------- ------ ----------
// ---------- Keytab ----------
// ---------- ------ ----------
// ---------- ------ ----------

func (ds *Datastore) CreateKeytab(filename string, file []byte, options ...QueryOpt) (int64, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return 0, errors.Wrap(err, "beginning transaction")
	}

	var id int64
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, CreateOp, "keytab", nil)
		// Default insert fields
		keytab := goqu.Record{
			"filename": filename,
			"file":     file,
		}
		q.AddFields(keytab)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if debug {
			color.Set(color.FgGreen)
			log.Println(q.dataset.ToInsertSql(q.fields))
			color.Unset()
		}
		// Execute query
		res, err := q.dataset.Insert(q.fields).Exec()
		if err != nil {
			return errors.Wrap(err, "executing query")
		}
		id, err = res.LastInsertId()
		if err != nil {
			return errors.Wrap(err, "retrieving id")
		}
		q.entityId = id
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}

		return nil
	})

	return id, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) ReadKeytabs(options ...QueryOpt) ([]Keytab, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return []Keytab{}, errors.Wrap(err, "beginning transaction")
	}

	var keytabs []Keytab
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, "", "keytab", nil)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if debug {
			color.Set(color.FgBlue)
			log.Println(q.dataset.ToSql())
			color.Unset()
		}
		// Execute query
		rows, err := getRows(tx, q.dataset)
		if err != nil {
			return err
		}
		defer rows.Close()
		keytabs, err = ScanKeytabs(rows)
		if err != nil {
			return err
		}
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}

		return nil
	})

	return keytabs, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) ReadKeytab(options ...QueryOpt) (Keytab, bool, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return Keytab{}, false, errors.Wrap(err, "beginning transaction")
	}

	var keytab Keytab
	var exists bool
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, "", "keytab", nil)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if debug {
			color.Set(color.FgBlue)
			log.Println(q.dataset.ToSql())
			color.Unset()
		}
		// Execute query
		row, err := getRow(tx, q.dataset)
		if err != nil {
			return err
		}
		keytab, err = ScanKeytab(row)
		if err == sql.ErrNoRows {
			return nil
		} else if err == nil {
			exists = true
		}
		if err != nil {
			return err
		}
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}

		return nil
	})

	return keytab, exists, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) UpdateKeytab(keytabId int64, options ...QueryOpt) error {
	tx, err := ds.db.Begin()
	if err != nil {
		return errors.Wrap(err, "beginning transaction")
	}

	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, UpdateOp, "keytab", keytabId)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if debug && len(q.fields) > 0 {
			color.Set(color.FgYellow)
			log.Println(q.dataset.ToUpdateSql(q.fields))
			color.Unset()
		}
		// Execute query
		if len(q.fields) > 0 {
			if _, err := q.dataset.Update(q.fields).Exec(); err != nil {
				return errors.Wrap(err, "executing query")
			}
		}
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}
		return nil
	})

	return errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) DeleteKeytab(keytabId int64, options ...QueryOpt) error {
	tx, err := ds.db.Begin()
	if err != nil {
		return errors.Wrap(err, "beginning transaction")
	}

	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, DeleteOp, "keytab", keytabId)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if debug {
			color.Set(color.FgRed)
			log.Println(q.dataset.ToDeleteSql())
			color.Unset()
		}
		// Execute query
		if _, err := q.dataset.Delete().Exec(); err != nil {
			return errors.Wrap(err, "executing query")
		}
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}

		return errors.Wrap(deletePrivilege(tx, ByEntityId(q.entityId), ByEntityType(q.entityType)), "deleting privileges")
	})

	return errors.Wrap(err, "committing transaction")
}
func createKeytab(tx *goqu.TxDatabase, filename string, file []byte, options ...QueryOpt) (int64, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, CreateOp, "keytab", nil)
	// Default insert fields
	keytab := goqu.Record{
		"filename": filename,
		"file":     file,
	}
	q.AddFields(keytab)
	for _, option := range options {
		if err := option(q); err != nil {
			return 0, errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgGreen)
		log.Println(q.dataset.ToInsertSql(q.fields))
		color.Unset()
	}
	// Execute query
	res, err := q.dataset.Insert(q.fields).Exec()
	if err != nil {
		return 0, errors.Wrap(err, "executing query")
	}
	id, err := res.LastInsertId()
	if err != nil {
		return 0, errors.Wrap(err, "retrieving id")
	}
	q.entityId = id
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return 0, errors.Wrap(err, "running post functions")
		}
	}

	return id, nil
}

func readKeytabs(tx *goqu.TxDatabase, options ...QueryOpt) ([]Keytab, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "", "keytab", nil)
	for _, option := range options {
		if err := option(q); err != nil {
			return []Keytab{}, errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgBlue)
		log.Println(q.dataset.ToSql())
		color.Unset()
	}
	// Execute query
	rows, err := getRows(tx, q.dataset)
	if err != nil {
		return []Keytab{}, err
	}
	defer rows.Close()
	keytabs, err := ScanKeytabs(rows)
	if err != nil {
		return []Keytab{}, err
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return []Keytab{}, errors.Wrap(err, "running post functions")
		}
	}

	// Scan rows to Keytabs
	return keytabs, nil
}

func readKeytab(tx *goqu.TxDatabase, options ...QueryOpt) (Keytab, bool, error) {
	var exists bool
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "", "keytab", nil)
	for _, option := range options {
		if err := option(q); err != nil {
			return Keytab{}, exists, errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgBlue)
		log.Println(q.dataset.ToSql())
		color.Unset()
	}
	// Execute query
	row, err := getRow(tx, q.dataset)
	if err != nil {
		return Keytab{}, false, err
	}
	ret_keytab, err := ScanKeytab(row)
	if err == sql.ErrNoRows {
		return Keytab{}, false, nil
	} else if err == nil {
		exists = true
	} else {
		return Keytab{}, false, err
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return Keytab{}, false, errors.Wrap(err, "running post functions")
		}
	}
	// Scan row to Keytab
	return ret_keytab, exists, nil
}

func updateKeytab(tx *goqu.TxDatabase, keytabId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, UpdateOp, "keytab", keytabId)
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if debug && len(q.fields) > 0 {
		color.Set(color.FgYellow)
		log.Println(q.dataset.ToUpdateSql(q.fields))
		color.Unset()
	}
	// Execute query
	if len(q.fields) > 0 {
		if _, err := q.dataset.Update(q.fields).Exec(); err != nil {
			return errors.Wrap(err, "executing query")
		}
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}
	return nil
}

func deleteKeytab(tx *goqu.TxDatabase, keytabId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, DeleteOp, "keytab", keytabId)
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgRed)
		log.Println(q.dataset.ToDeleteSql())
		color.Unset()
	}
	// Execute query
	if _, err := q.dataset.Delete().Exec(); err != nil {
		return errors.Wrap(err, "executing query")
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}

	return nil

}

// ---------- ---- ----------
// ---------- ---- ----------
// ---------- Meta ----------
// ---------- ---- ----------
// ---------- ---- ----------

func (ds *Datastore) CreateMeta(key string, options ...QueryOpt) (int64, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return 0, errors.Wrap(err, "beginning transaction")
	}

	var id int64
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, CreateOp, "meta", nil)
		// Default insert fields
		meta := goqu.Record{
			"key": key,
		}
		q.AddFields(meta)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if debug {
			color.Set(color.FgGreen)
			log.Println(q.dataset.ToInsertSql(q.fields))
			color.Unset()
		}
		// Execute query
		res, err := q.dataset.Insert(q.fields).Exec()
		if err != nil {
			return errors.Wrap(err, "executing query")
		}
		id, err = res.LastInsertId()
		if err != nil {
			return errors.Wrap(err, "retrieving id")
		}
		q.entityId = id
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}

		return nil
	})

	return id, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) ReadMetas(options ...QueryOpt) ([]Meta, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return []Meta{}, errors.Wrap(err, "beginning transaction")
	}

	var metas []Meta
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, "", "meta", nil)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if debug {
			color.Set(color.FgBlue)
			log.Println(q.dataset.ToSql())
			color.Unset()
		}
		// Execute query
		rows, err := getRows(tx, q.dataset)
		if err != nil {
			return err
		}
		defer rows.Close()
		metas, err = ScanMetas(rows)
		if err != nil {
			return err
		}
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}

		return nil
	})

	return metas, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) ReadMeta(options ...QueryOpt) (Meta, bool, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return Meta{}, false, errors.Wrap(err, "beginning transaction")
	}

	var meta Meta
	var exists bool
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, "", "meta", nil)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if debug {
			color.Set(color.FgBlue)
			log.Println(q.dataset.ToSql())
			color.Unset()
		}
		// Execute query
		row, err := getRow(tx, q.dataset)
		if err != nil {
			return err
		}
		meta, err = ScanMeta(row)
		if err == sql.ErrNoRows {
			return nil
		} else if err == nil {
			exists = true
		}
		if err != nil {
			return err
		}
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}

		return nil
	})

	return meta, exists, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) UpdateMeta(metaId int64, options ...QueryOpt) error {
	tx, err := ds.db.Begin()
	if err != nil {
		return errors.Wrap(err, "beginning transaction")
	}

	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, UpdateOp, "meta", metaId)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if debug && len(q.fields) > 0 {
			color.Set(color.FgYellow)
			log.Println(q.dataset.ToUpdateSql(q.fields))
			color.Unset()
		}
		// Execute query
		if len(q.fields) > 0 {
			if _, err := q.dataset.Update(q.fields).Exec(); err != nil {
				return errors.Wrap(err, "executing query")
			}
		}
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}
		return nil
	})

	return errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) DeleteMeta(metaId int64, options ...QueryOpt) error {
	tx, err := ds.db.Begin()
	if err != nil {
		return errors.Wrap(err, "beginning transaction")
	}

	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, DeleteOp, "meta", metaId)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if debug {
			color.Set(color.FgRed)
			log.Println(q.dataset.ToDeleteSql())
			color.Unset()
		}
		// Execute query
		if _, err := q.dataset.Delete().Exec(); err != nil {
			return errors.Wrap(err, "executing query")
		}
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}

		return errors.Wrap(deletePrivilege(tx, ByEntityId(q.entityId), ByEntityType(q.entityType)), "deleting privileges")
	})

	return errors.Wrap(err, "committing transaction")
}
func createMeta(tx *goqu.TxDatabase, key string, options ...QueryOpt) (int64, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, CreateOp, "meta", nil)
	// Default insert fields
	meta := goqu.Record{
		"key": key,
	}
	q.AddFields(meta)
	for _, option := range options {
		if err := option(q); err != nil {
			return 0, errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgGreen)
		log.Println(q.dataset.ToInsertSql(q.fields))
		color.Unset()
	}
	// Execute query
	res, err := q.dataset.Insert(q.fields).Exec()
	if err != nil {
		return 0, errors.Wrap(err, "executing query")
	}
	id, err := res.LastInsertId()
	if err != nil {
		return 0, errors.Wrap(err, "retrieving id")
	}
	q.entityId = id
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return 0, errors.Wrap(err, "running post functions")
		}
	}

	return id, nil
}

func readMetas(tx *goqu.TxDatabase, options ...QueryOpt) ([]Meta, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "", "meta", nil)
	for _, option := range options {
		if err := option(q); err != nil {
			return []Meta{}, errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgBlue)
		log.Println(q.dataset.ToSql())
		color.Unset()
	}
	// Execute query
	rows, err := getRows(tx, q.dataset)
	if err != nil {
		return []Meta{}, err
	}
	defer rows.Close()
	metas, err := ScanMetas(rows)
	if err != nil {
		return []Meta{}, err
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return []Meta{}, errors.Wrap(err, "running post functions")
		}
	}

	// Scan rows to Metas
	return metas, nil
}

func readMeta(tx *goqu.TxDatabase, options ...QueryOpt) (Meta, bool, error) {
	var exists bool
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "", "meta", nil)
	for _, option := range options {
		if err := option(q); err != nil {
			return Meta{}, exists, errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgBlue)
		log.Println(q.dataset.ToSql())
		color.Unset()
	}
	// Execute query
	row, err := getRow(tx, q.dataset)
	if err != nil {
		return Meta{}, false, err
	}
	ret_meta, err := ScanMeta(row)
	if err == sql.ErrNoRows {
		return Meta{}, false, nil
	} else if err == nil {
		exists = true
	} else {
		return Meta{}, false, err
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return Meta{}, false, errors.Wrap(err, "running post functions")
		}
	}
	// Scan row to Meta
	return ret_meta, exists, nil
}

func updateMeta(tx *goqu.TxDatabase, metaId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, UpdateOp, "meta", metaId)
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if debug && len(q.fields) > 0 {
		color.Set(color.FgYellow)
		log.Println(q.dataset.ToUpdateSql(q.fields))
		color.Unset()
	}
	// Execute query
	if len(q.fields) > 0 {
		if _, err := q.dataset.Update(q.fields).Exec(); err != nil {
			return errors.Wrap(err, "executing query")
		}
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}
	return nil
}

func deleteMeta(tx *goqu.TxDatabase, metaId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, DeleteOp, "meta", metaId)
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgRed)
		log.Println(q.dataset.ToDeleteSql())
		color.Unset()
	}
	// Execute query
	if _, err := q.dataset.Delete().Exec(); err != nil {
		return errors.Wrap(err, "executing query")
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}

	return nil

}

// ---------- ------------- ----------
// ---------- ------------- ----------
// ---------- modelCategory ----------
// ---------- ------------- ----------
// ---------- ------------- ----------

func createModelCategory(tx *goqu.TxDatabase, name string, options ...QueryOpt) (int64, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, CreateOp, "model_category", nil)
	// Default insert fields
	modelCategory := goqu.Record{
		"name": name,
	}
	q.AddFields(modelCategory)
	for _, option := range options {
		if err := option(q); err != nil {
			return 0, errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgGreen)
		log.Println(q.dataset.ToInsertSql(q.fields))
		color.Unset()
	}
	// Execute query
	res, err := q.dataset.Insert(q.fields).Exec()
	if err != nil {
		return 0, errors.Wrap(err, "executing query")
	}
	id, err := res.LastInsertId()
	if err != nil {
		return 0, errors.Wrap(err, "retrieving id")
	}
	q.entityId = id
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return 0, errors.Wrap(err, "running post functions")
		}
	}

	return id, nil
}

func readModelCategories(tx *goqu.TxDatabase, options ...QueryOpt) ([]modelCategory, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "", "model_category", nil)
	for _, option := range options {
		if err := option(q); err != nil {
			return []modelCategory{}, errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgBlue)
		log.Println(q.dataset.ToSql())
		color.Unset()
	}
	// Execute query
	rows, err := getRows(tx, q.dataset)
	if err != nil {
		return []modelCategory{}, err
	}
	defer rows.Close()
	modelCategories, err := ScanModelCategorys(rows)
	if err != nil {
		return []modelCategory{}, err
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return []modelCategory{}, errors.Wrap(err, "running post functions")
		}
	}

	// Scan rows to modelCategories
	return modelCategories, nil
}

func readModelCategory(tx *goqu.TxDatabase, options ...QueryOpt) (modelCategory, bool, error) {
	var exists bool
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "", "model_category", nil)
	for _, option := range options {
		if err := option(q); err != nil {
			return modelCategory{}, exists, errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgBlue)
		log.Println(q.dataset.ToSql())
		color.Unset()
	}
	// Execute query
	row, err := getRow(tx, q.dataset)
	if err != nil {
		return modelCategory{}, false, err
	}
	ret_modelCategory, err := ScanModelCategory(row)
	if err == sql.ErrNoRows {
		return modelCategory{}, false, nil
	} else if err == nil {
		exists = true
	} else {
		return modelCategory{}, false, err
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return modelCategory{}, false, errors.Wrap(err, "running post functions")
		}
	}
	// Scan row to modelCategory
	return ret_modelCategory, exists, nil
}

func updateModelCategory(tx *goqu.TxDatabase, modelCategoryId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, UpdateOp, "model_category", modelCategoryId)
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if debug && len(q.fields) > 0 {
		color.Set(color.FgYellow)
		log.Println(q.dataset.ToUpdateSql(q.fields))
		color.Unset()
	}
	// Execute query
	if len(q.fields) > 0 {
		if _, err := q.dataset.Update(q.fields).Exec(); err != nil {
			return errors.Wrap(err, "executing query")
		}
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}
	return nil
}

func deleteModelCategory(tx *goqu.TxDatabase, modelCategoryId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, DeleteOp, "model_category", modelCategoryId)
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgRed)
		log.Println(q.dataset.ToDeleteSql())
		color.Unset()
	}
	// Execute query
	if _, err := q.dataset.Delete().Exec(); err != nil {
		return errors.Wrap(err, "executing query")
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}

	return nil

}

// ---------- ----- ----------
// ---------- ----- ----------
// ---------- Model ----------
// ---------- ----- ----------
// ---------- ----- ----------

func (ds *Datastore) CreateModel(name, modelKey, algorithm, modelCategory, responseColumn string, options ...QueryOpt) (int64, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return 0, errors.Wrap(err, "beginning transaction")
	}

	var id int64
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, CreateOp, "model", nil)
		// Default insert fields
		model := goqu.Record{
			"name":                 name,
			"model_key":            modelKey,
			"algorithm":            algorithm,
			"model_category":       modelCategory,
			"response_column_name": responseColumn,
			"created":              time.Now(),
		}
		q.AddFields(model)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if debug {
			color.Set(color.FgGreen)
			log.Println(q.dataset.ToInsertSql(q.fields))
			color.Unset()
		}
		// Execute query
		res, err := q.dataset.Insert(q.fields).Exec()
		if err != nil {
			return errors.Wrap(err, "executing query")
		}
		id, err = res.LastInsertId()
		if err != nil {
			return errors.Wrap(err, "retrieving id")
		}
		q.entityId = id
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}

		return nil
	})

	return id, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) ReadModels(options ...QueryOpt) ([]Model, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return []Model{}, errors.Wrap(err, "beginning transaction")
	}

	var models []Model
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, "", "model", nil)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if debug {
			color.Set(color.FgBlue)
			log.Println(q.dataset.ToSql())
			color.Unset()
		}
		// Execute query
		rows, err := getRows(tx, q.dataset)
		if err != nil {
			return err
		}
		defer rows.Close()
		models, err = ScanModels(rows)
		if err != nil {
			return err
		}
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}

		return nil
	})

	return models, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) ReadModel(options ...QueryOpt) (Model, bool, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return Model{}, false, errors.Wrap(err, "beginning transaction")
	}

	var model Model
	var exists bool
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, "", "model", nil)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if debug {
			color.Set(color.FgBlue)
			log.Println(q.dataset.ToSql())
			color.Unset()
		}
		// Execute query
		row, err := getRow(tx, q.dataset)
		if err != nil {
			return err
		}
		model, err = ScanModel(row)
		if err == sql.ErrNoRows {
			return nil
		} else if err == nil {
			exists = true
		}
		if err != nil {
			return err
		}
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}

		return nil
	})

	return model, exists, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) UpdateModel(modelId int64, options ...QueryOpt) error {
	tx, err := ds.db.Begin()
	if err != nil {
		return errors.Wrap(err, "beginning transaction")
	}

	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, UpdateOp, "model", modelId)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if debug && len(q.fields) > 0 {
			color.Set(color.FgYellow)
			log.Println(q.dataset.ToUpdateSql(q.fields))
			color.Unset()
		}
		// Execute query
		if len(q.fields) > 0 {
			if _, err := q.dataset.Update(q.fields).Exec(); err != nil {
				return errors.Wrap(err, "executing query")
			}
		}
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}
		return nil
	})

	return errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) DeleteModel(modelId int64, options ...QueryOpt) error {
	tx, err := ds.db.Begin()
	if err != nil {
		return errors.Wrap(err, "beginning transaction")
	}

	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, DeleteOp, "model", modelId)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if debug {
			color.Set(color.FgRed)
			log.Println(q.dataset.ToDeleteSql())
			color.Unset()
		}
		// Execute query
		if _, err := q.dataset.Delete().Exec(); err != nil {
			return errors.Wrap(err, "executing query")
		}
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}

		return errors.Wrap(deletePrivilege(tx, ByEntityId(q.entityId), ByEntityType(q.entityType)), "deleting privileges")
	})

	return errors.Wrap(err, "committing transaction")
}
func createModel(tx *goqu.TxDatabase, name, modelKey, algorithm, modelCategory, responseColumn string, options ...QueryOpt) (int64, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, CreateOp, "model", nil)
	// Default insert fields
	model := goqu.Record{
		"name":                 name,
		"model_key":            modelKey,
		"algorithm":            algorithm,
		"model_category":       modelCategory,
		"response_column_name": responseColumn,
		"created":              time.Now(),
	}
	q.AddFields(model)
	for _, option := range options {
		if err := option(q); err != nil {
			return 0, errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgGreen)
		log.Println(q.dataset.ToInsertSql(q.fields))
		color.Unset()
	}
	// Execute query
	res, err := q.dataset.Insert(q.fields).Exec()
	if err != nil {
		return 0, errors.Wrap(err, "executing query")
	}
	id, err := res.LastInsertId()
	if err != nil {
		return 0, errors.Wrap(err, "retrieving id")
	}
	q.entityId = id
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return 0, errors.Wrap(err, "running post functions")
		}
	}

	return id, nil
}

func readModels(tx *goqu.TxDatabase, options ...QueryOpt) ([]Model, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "", "model", nil)
	for _, option := range options {
		if err := option(q); err != nil {
			return []Model{}, errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgBlue)
		log.Println(q.dataset.ToSql())
		color.Unset()
	}
	// Execute query
	rows, err := getRows(tx, q.dataset)
	if err != nil {
		return []Model{}, err
	}
	defer rows.Close()
	models, err := ScanModels(rows)
	if err != nil {
		return []Model{}, err
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return []Model{}, errors.Wrap(err, "running post functions")
		}
	}

	// Scan rows to Models
	return models, nil
}

func readModel(tx *goqu.TxDatabase, options ...QueryOpt) (Model, bool, error) {
	var exists bool
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "", "model", nil)
	for _, option := range options {
		if err := option(q); err != nil {
			return Model{}, exists, errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgBlue)
		log.Println(q.dataset.ToSql())
		color.Unset()
	}
	// Execute query
	row, err := getRow(tx, q.dataset)
	if err != nil {
		return Model{}, false, err
	}
	ret_model, err := ScanModel(row)
	if err == sql.ErrNoRows {
		return Model{}, false, nil
	} else if err == nil {
		exists = true
	} else {
		return Model{}, false, err
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return Model{}, false, errors.Wrap(err, "running post functions")
		}
	}
	// Scan row to Model
	return ret_model, exists, nil
}

func updateModel(tx *goqu.TxDatabase, modelId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, UpdateOp, "model", modelId)
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if debug && len(q.fields) > 0 {
		color.Set(color.FgYellow)
		log.Println(q.dataset.ToUpdateSql(q.fields))
		color.Unset()
	}
	// Execute query
	if len(q.fields) > 0 {
		if _, err := q.dataset.Update(q.fields).Exec(); err != nil {
			return errors.Wrap(err, "executing query")
		}
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}
	return nil
}

func deleteModel(tx *goqu.TxDatabase, modelId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, DeleteOp, "model", modelId)
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgRed)
		log.Println(q.dataset.ToDeleteSql())
		color.Unset()
	}
	// Execute query
	if _, err := q.dataset.Delete().Exec(); err != nil {
		return errors.Wrap(err, "executing query")
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}

	return nil

}

// ---------- ---------------- ----------
// ---------- ---------------- ----------
// ---------- multinomialModel ----------
// ---------- ---------------- ----------
// ---------- ---------------- ----------

func createMultinomialModel(tx *goqu.TxDatabase, modelId int64, mse, rSquared, logloss float64, options ...QueryOpt) (int64, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, CreateOp, "multinomial_model", nil)
	// Default insert fields
	multinomialModel := goqu.Record{
		"model_id":  modelId,
		"mse":       mse,
		"r_squared": rSquared,
		"logloss":   logloss,
	}
	q.AddFields(multinomialModel)
	for _, option := range options {
		if err := option(q); err != nil {
			return 0, errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgGreen)
		log.Println(q.dataset.ToInsertSql(q.fields))
		color.Unset()
	}
	// Execute query
	res, err := q.dataset.Insert(q.fields).Exec()
	if err != nil {
		return 0, errors.Wrap(err, "executing query")
	}
	id, err := res.LastInsertId()
	if err != nil {
		return 0, errors.Wrap(err, "retrieving id")
	}
	q.entityId = id
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return 0, errors.Wrap(err, "running post functions")
		}
	}

	return id, nil
}

func readMultinomialModels(tx *goqu.TxDatabase, options ...QueryOpt) ([]multinomialModel, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "", "multinomial_model", nil)
	for _, option := range options {
		if err := option(q); err != nil {
			return []multinomialModel{}, errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgBlue)
		log.Println(q.dataset.ToSql())
		color.Unset()
	}
	// Execute query
	rows, err := getRows(tx, q.dataset)
	if err != nil {
		return []multinomialModel{}, err
	}
	defer rows.Close()
	multinomialModels, err := ScanMultinomialModels(rows)
	if err != nil {
		return []multinomialModel{}, err
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return []multinomialModel{}, errors.Wrap(err, "running post functions")
		}
	}

	// Scan rows to multinomialModels
	return multinomialModels, nil
}

func readMultinomialModel(tx *goqu.TxDatabase, options ...QueryOpt) (multinomialModel, bool, error) {
	var exists bool
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "", "multinomial_model", nil)
	for _, option := range options {
		if err := option(q); err != nil {
			return multinomialModel{}, exists, errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgBlue)
		log.Println(q.dataset.ToSql())
		color.Unset()
	}
	// Execute query
	row, err := getRow(tx, q.dataset)
	if err != nil {
		return multinomialModel{}, false, err
	}
	ret_multinomialModel, err := ScanMultinomialModel(row)
	if err == sql.ErrNoRows {
		return multinomialModel{}, false, nil
	} else if err == nil {
		exists = true
	} else {
		return multinomialModel{}, false, err
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return multinomialModel{}, false, errors.Wrap(err, "running post functions")
		}
	}
	// Scan row to multinomialModel
	return ret_multinomialModel, exists, nil
}

func updateMultinomialModel(tx *goqu.TxDatabase, multinomialModelId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, UpdateOp, "multinomial_model", multinomialModelId)
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if debug && len(q.fields) > 0 {
		color.Set(color.FgYellow)
		log.Println(q.dataset.ToUpdateSql(q.fields))
		color.Unset()
	}
	// Execute query
	if len(q.fields) > 0 {
		if _, err := q.dataset.Update(q.fields).Exec(); err != nil {
			return errors.Wrap(err, "executing query")
		}
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}
	return nil
}

func deleteMultinomialModel(tx *goqu.TxDatabase, multinomialModelId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, DeleteOp, "multinomial_model", multinomialModelId)
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgRed)
		log.Println(q.dataset.ToDeleteSql())
		color.Unset()
	}
	// Execute query
	if _, err := q.dataset.Delete().Exec(); err != nil {
		return errors.Wrap(err, "executing query")
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}

	return nil

}

// ---------- ---------- ----------
// ---------- ---------- ----------
// ---------- Permission ----------
// ---------- ---------- ----------
// ---------- ---------- ----------

func (ds *Datastore) CreatePermission(code, description string, options ...QueryOpt) (int64, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return 0, errors.Wrap(err, "beginning transaction")
	}

	var id int64
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, CreateOp, "permission", nil)
		// Default insert fields
		permission := goqu.Record{
			"code":        code,
			"description": description,
		}
		q.AddFields(permission)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if debug {
			color.Set(color.FgGreen)
			log.Println(q.dataset.ToInsertSql(q.fields))
			color.Unset()
		}
		// Execute query
		res, err := q.dataset.Insert(q.fields).Exec()
		if err != nil {
			return errors.Wrap(err, "executing query")
		}
		id, err = res.LastInsertId()
		if err != nil {
			return errors.Wrap(err, "retrieving id")
		}
		q.entityId = id
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}

		return nil
	})

	return id, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) ReadPermissions(options ...QueryOpt) ([]Permission, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return []Permission{}, errors.Wrap(err, "beginning transaction")
	}

	var permissions []Permission
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, "", "permission", nil)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if debug {
			color.Set(color.FgBlue)
			log.Println(q.dataset.ToSql())
			color.Unset()
		}
		// Execute query
		rows, err := getRows(tx, q.dataset)
		if err != nil {
			return err
		}
		defer rows.Close()
		permissions, err = ScanPermissions(rows)
		if err != nil {
			return err
		}
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}

		return nil
	})

	return permissions, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) ReadPermission(options ...QueryOpt) (Permission, bool, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return Permission{}, false, errors.Wrap(err, "beginning transaction")
	}

	var permission Permission
	var exists bool
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, "", "permission", nil)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if debug {
			color.Set(color.FgBlue)
			log.Println(q.dataset.ToSql())
			color.Unset()
		}
		// Execute query
		row, err := getRow(tx, q.dataset)
		if err != nil {
			return err
		}
		permission, err = ScanPermission(row)
		if err == sql.ErrNoRows {
			return nil
		} else if err == nil {
			exists = true
		}
		if err != nil {
			return err
		}
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}

		return nil
	})

	return permission, exists, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) UpdatePermission(permissionId int64, options ...QueryOpt) error {
	tx, err := ds.db.Begin()
	if err != nil {
		return errors.Wrap(err, "beginning transaction")
	}

	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, UpdateOp, "permission", permissionId)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if debug && len(q.fields) > 0 {
			color.Set(color.FgYellow)
			log.Println(q.dataset.ToUpdateSql(q.fields))
			color.Unset()
		}
		// Execute query
		if len(q.fields) > 0 {
			if _, err := q.dataset.Update(q.fields).Exec(); err != nil {
				return errors.Wrap(err, "executing query")
			}
		}
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}
		return nil
	})

	return errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) DeletePermission(permissionId int64, options ...QueryOpt) error {
	tx, err := ds.db.Begin()
	if err != nil {
		return errors.Wrap(err, "beginning transaction")
	}

	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, DeleteOp, "permission", permissionId)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if debug {
			color.Set(color.FgRed)
			log.Println(q.dataset.ToDeleteSql())
			color.Unset()
		}
		// Execute query
		if _, err := q.dataset.Delete().Exec(); err != nil {
			return errors.Wrap(err, "executing query")
		}
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}

		return errors.Wrap(deletePrivilege(tx, ByEntityId(q.entityId), ByEntityType(q.entityType)), "deleting privileges")
	})

	return errors.Wrap(err, "committing transaction")
}
func createPermission(tx *goqu.TxDatabase, code, description string, options ...QueryOpt) (int64, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, CreateOp, "permission", nil)
	// Default insert fields
	permission := goqu.Record{
		"code":        code,
		"description": description,
	}
	q.AddFields(permission)
	for _, option := range options {
		if err := option(q); err != nil {
			return 0, errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgGreen)
		log.Println(q.dataset.ToInsertSql(q.fields))
		color.Unset()
	}
	// Execute query
	res, err := q.dataset.Insert(q.fields).Exec()
	if err != nil {
		return 0, errors.Wrap(err, "executing query")
	}
	id, err := res.LastInsertId()
	if err != nil {
		return 0, errors.Wrap(err, "retrieving id")
	}
	q.entityId = id
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return 0, errors.Wrap(err, "running post functions")
		}
	}

	return id, nil
}

func readPermissions(tx *goqu.TxDatabase, options ...QueryOpt) ([]Permission, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "", "permission", nil)
	for _, option := range options {
		if err := option(q); err != nil {
			return []Permission{}, errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgBlue)
		log.Println(q.dataset.ToSql())
		color.Unset()
	}
	// Execute query
	rows, err := getRows(tx, q.dataset)
	if err != nil {
		return []Permission{}, err
	}
	defer rows.Close()
	permissions, err := ScanPermissions(rows)
	if err != nil {
		return []Permission{}, err
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return []Permission{}, errors.Wrap(err, "running post functions")
		}
	}

	// Scan rows to Permissions
	return permissions, nil
}

func readPermission(tx *goqu.TxDatabase, options ...QueryOpt) (Permission, bool, error) {
	var exists bool
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "", "permission", nil)
	for _, option := range options {
		if err := option(q); err != nil {
			return Permission{}, exists, errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgBlue)
		log.Println(q.dataset.ToSql())
		color.Unset()
	}
	// Execute query
	row, err := getRow(tx, q.dataset)
	if err != nil {
		return Permission{}, false, err
	}
	ret_permission, err := ScanPermission(row)
	if err == sql.ErrNoRows {
		return Permission{}, false, nil
	} else if err == nil {
		exists = true
	} else {
		return Permission{}, false, err
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return Permission{}, false, errors.Wrap(err, "running post functions")
		}
	}
	// Scan row to Permission
	return ret_permission, exists, nil
}

func updatePermission(tx *goqu.TxDatabase, permissionId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, UpdateOp, "permission", permissionId)
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if debug && len(q.fields) > 0 {
		color.Set(color.FgYellow)
		log.Println(q.dataset.ToUpdateSql(q.fields))
		color.Unset()
	}
	// Execute query
	if len(q.fields) > 0 {
		if _, err := q.dataset.Update(q.fields).Exec(); err != nil {
			return errors.Wrap(err, "executing query")
		}
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}
	return nil
}

func deletePermission(tx *goqu.TxDatabase, permissionId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, DeleteOp, "permission", permissionId)
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgRed)
		log.Println(q.dataset.ToDeleteSql())
		color.Unset()
	}
	// Execute query
	if _, err := q.dataset.Delete().Exec(); err != nil {
		return errors.Wrap(err, "executing query")
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}

	return nil

}

// ---------- --------- ----------
// ---------- --------- ----------
// ---------- Privilege ----------
// ---------- --------- ----------
// ---------- --------- ----------

func (ds *Datastore) CreatePrivilege(typ string, identityId, workgroupId int64, entityType string, entityId int64, options ...QueryOpt) (int64, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return 0, errors.Wrap(err, "beginning transaction")
	}

	var id int64
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, CreateOp, "privilege", nil)
		// Default insert fields
		privilege := goqu.Record{
			"privilege_type": typ,
			"identity_id":    identityId,
			"workgroup_id":   workgroupId,
			"entity_type":    entityType,
			"entity_id":      entityId,
		}
		q.AddFields(privilege)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if debug {
			color.Set(color.FgGreen)
			log.Println(q.dataset.ToInsertSql(q.fields))
			color.Unset()
		}
		// Execute query
		res, err := q.dataset.Insert(q.fields).Exec()
		if err != nil {
			return errors.Wrap(err, "executing query")
		}
		id, err = res.LastInsertId()
		if err != nil {
			return errors.Wrap(err, "retrieving id")
		}
		q.entityId = id
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}

		return nil
	})

	return id, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) ReadPrivileges(options ...QueryOpt) ([]Privilege, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return []Privilege{}, errors.Wrap(err, "beginning transaction")
	}

	var privileges []Privilege
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, "", "privilege", nil)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if debug {
			color.Set(color.FgBlue)
			log.Println(q.dataset.ToSql())
			color.Unset()
		}
		// Execute query
		rows, err := getRows(tx, q.dataset)
		if err != nil {
			return err
		}
		defer rows.Close()
		privileges, err = ScanPrivileges(rows)
		if err != nil {
			return err
		}
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}

		return nil
	})

	return privileges, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) ReadPrivilege(options ...QueryOpt) (Privilege, bool, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return Privilege{}, false, errors.Wrap(err, "beginning transaction")
	}

	var privilege Privilege
	var exists bool
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, "", "privilege", nil)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if debug {
			color.Set(color.FgBlue)
			log.Println(q.dataset.ToSql())
			color.Unset()
		}
		// Execute query
		row, err := getRow(tx, q.dataset)
		if err != nil {
			return err
		}
		privilege, err = ScanPrivilege(row)
		if err == sql.ErrNoRows {
			return nil
		} else if err == nil {
			exists = true
		}
		if err != nil {
			return err
		}
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}

		return nil
	})

	return privilege, exists, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) UpdatePrivilege(options ...QueryOpt) error {
	tx, err := ds.db.Begin()
	if err != nil {
		return errors.Wrap(err, "beginning transaction")
	}

	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, UpdateOp, "privilege", nil)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if debug && len(q.fields) > 0 {
			color.Set(color.FgYellow)
			log.Println(q.dataset.ToUpdateSql(q.fields))
			color.Unset()
		}
		// Execute query
		if len(q.fields) > 0 {
			if _, err := q.dataset.Update(q.fields).Exec(); err != nil {
				return errors.Wrap(err, "executing query")
			}
		}
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}
		return nil
	})

	return errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) DeletePrivilege(options ...QueryOpt) error {
	tx, err := ds.db.Begin()
	if err != nil {
		return errors.Wrap(err, "beginning transaction")
	}

	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, DeleteOp, "privilege", nil)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if debug {
			color.Set(color.FgRed)
			log.Println(q.dataset.ToDeleteSql())
			color.Unset()
		}
		// Execute query
		if _, err := q.dataset.Delete().Exec(); err != nil {
			return errors.Wrap(err, "executing query")
		}
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}

		return errors.Wrap(deletePrivilege(tx, ByEntityId(q.entityId), ByEntityType(q.entityType)), "deleting privileges")
	})

	return errors.Wrap(err, "committing transaction")
}
func createPrivilege(tx *goqu.TxDatabase, typ string, identityId, workgroupId int64, entityType string, entityId int64, options ...QueryOpt) (int64, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, CreateOp, "privilege", nil)
	// Default insert fields
	privilege := goqu.Record{
		"privilege_type": typ,
		"identity_id":    identityId,
		"workgroup_id":   workgroupId,
		"entity_type":    entityType,
		"entity_id":      entityId,
	}
	q.AddFields(privilege)
	for _, option := range options {
		if err := option(q); err != nil {
			return 0, errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgGreen)
		log.Println(q.dataset.ToInsertSql(q.fields))
		color.Unset()
	}
	// Execute query
	res, err := q.dataset.Insert(q.fields).Exec()
	if err != nil {
		return 0, errors.Wrap(err, "executing query")
	}
	id, err := res.LastInsertId()
	if err != nil {
		return 0, errors.Wrap(err, "retrieving id")
	}
	q.entityId = id
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return 0, errors.Wrap(err, "running post functions")
		}
	}

	return id, nil
}

func readPrivileges(tx *goqu.TxDatabase, options ...QueryOpt) ([]Privilege, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "", "privilege", nil)
	for _, option := range options {
		if err := option(q); err != nil {
			return []Privilege{}, errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgBlue)
		log.Println(q.dataset.ToSql())
		color.Unset()
	}
	// Execute query
	rows, err := getRows(tx, q.dataset)
	if err != nil {
		return []Privilege{}, err
	}
	defer rows.Close()
	privileges, err := ScanPrivileges(rows)
	if err != nil {
		return []Privilege{}, err
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return []Privilege{}, errors.Wrap(err, "running post functions")
		}
	}

	// Scan rows to Privileges
	return privileges, nil
}

func readPrivilege(tx *goqu.TxDatabase, options ...QueryOpt) (Privilege, bool, error) {
	var exists bool
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "", "privilege", nil)
	for _, option := range options {
		if err := option(q); err != nil {
			return Privilege{}, exists, errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgBlue)
		log.Println(q.dataset.ToSql())
		color.Unset()
	}
	// Execute query
	row, err := getRow(tx, q.dataset)
	if err != nil {
		return Privilege{}, false, err
	}
	ret_privilege, err := ScanPrivilege(row)
	if err == sql.ErrNoRows {
		return Privilege{}, false, nil
	} else if err == nil {
		exists = true
	} else {
		return Privilege{}, false, err
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return Privilege{}, false, errors.Wrap(err, "running post functions")
		}
	}
	// Scan row to Privilege
	return ret_privilege, exists, nil
}

func updatePrivilege(tx *goqu.TxDatabase, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, UpdateOp, "privilege", nil)
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if debug && len(q.fields) > 0 {
		color.Set(color.FgYellow)
		log.Println(q.dataset.ToUpdateSql(q.fields))
		color.Unset()
	}
	// Execute query
	if len(q.fields) > 0 {
		if _, err := q.dataset.Update(q.fields).Exec(); err != nil {
			return errors.Wrap(err, "executing query")
		}
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}
	return nil
}

func deletePrivilege(tx *goqu.TxDatabase, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, DeleteOp, "privilege", nil)
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgRed)
		log.Println(q.dataset.ToDeleteSql())
		color.Unset()
	}
	// Execute query
	if _, err := q.dataset.Delete().Exec(); err != nil {
		return errors.Wrap(err, "executing query")
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}

	return nil

}

// ---------- ------- ----------
// ---------- ------- ----------
// ---------- Project ----------
// ---------- ------- ----------
// ---------- ------- ----------

func (ds *Datastore) CreateProject(name, description, modelCategory string, options ...QueryOpt) (int64, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return 0, errors.Wrap(err, "beginning transaction")
	}

	var id int64
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, CreateOp, "project", nil)
		// Default insert fields
		project := goqu.Record{
			"name":           name,
			"description":    description,
			"model_category": modelCategory,
			"created":        time.Now(),
		}
		q.AddFields(project)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if debug {
			color.Set(color.FgGreen)
			log.Println(q.dataset.ToInsertSql(q.fields))
			color.Unset()
		}
		// Execute query
		res, err := q.dataset.Insert(q.fields).Exec()
		if err != nil {
			return errors.Wrap(err, "executing query")
		}
		id, err = res.LastInsertId()
		if err != nil {
			return errors.Wrap(err, "retrieving id")
		}
		q.entityId = id
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}

		return nil
	})

	return id, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) ReadProjects(options ...QueryOpt) ([]Project, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return []Project{}, errors.Wrap(err, "beginning transaction")
	}

	var projects []Project
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, "", "project", nil)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if debug {
			color.Set(color.FgBlue)
			log.Println(q.dataset.ToSql())
			color.Unset()
		}
		// Execute query
		rows, err := getRows(tx, q.dataset)
		if err != nil {
			return err
		}
		defer rows.Close()
		projects, err = ScanProjects(rows)
		if err != nil {
			return err
		}
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}

		return nil
	})

	return projects, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) ReadProject(options ...QueryOpt) (Project, bool, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return Project{}, false, errors.Wrap(err, "beginning transaction")
	}

	var project Project
	var exists bool
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, "", "project", nil)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if debug {
			color.Set(color.FgBlue)
			log.Println(q.dataset.ToSql())
			color.Unset()
		}
		// Execute query
		row, err := getRow(tx, q.dataset)
		if err != nil {
			return err
		}
		project, err = ScanProject(row)
		if err == sql.ErrNoRows {
			return nil
		} else if err == nil {
			exists = true
		}
		if err != nil {
			return err
		}
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}

		return nil
	})

	return project, exists, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) UpdateProject(projectId int64, options ...QueryOpt) error {
	tx, err := ds.db.Begin()
	if err != nil {
		return errors.Wrap(err, "beginning transaction")
	}

	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, UpdateOp, "project", projectId)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if debug && len(q.fields) > 0 {
			color.Set(color.FgYellow)
			log.Println(q.dataset.ToUpdateSql(q.fields))
			color.Unset()
		}
		// Execute query
		if len(q.fields) > 0 {
			if _, err := q.dataset.Update(q.fields).Exec(); err != nil {
				return errors.Wrap(err, "executing query")
			}
		}
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}
		return nil
	})

	return errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) DeleteProject(projectId int64, options ...QueryOpt) error {
	tx, err := ds.db.Begin()
	if err != nil {
		return errors.Wrap(err, "beginning transaction")
	}

	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, DeleteOp, "project", projectId)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if debug {
			color.Set(color.FgRed)
			log.Println(q.dataset.ToDeleteSql())
			color.Unset()
		}
		// Execute query
		if _, err := q.dataset.Delete().Exec(); err != nil {
			return errors.Wrap(err, "executing query")
		}
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}

		return errors.Wrap(deletePrivilege(tx, ByEntityId(q.entityId), ByEntityType(q.entityType)), "deleting privileges")
	})

	return errors.Wrap(err, "committing transaction")
}
func createProject(tx *goqu.TxDatabase, name, description, modelCategory string, options ...QueryOpt) (int64, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, CreateOp, "project", nil)
	// Default insert fields
	project := goqu.Record{
		"name":           name,
		"description":    description,
		"model_category": modelCategory,
		"created":        time.Now(),
	}
	q.AddFields(project)
	for _, option := range options {
		if err := option(q); err != nil {
			return 0, errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgGreen)
		log.Println(q.dataset.ToInsertSql(q.fields))
		color.Unset()
	}
	// Execute query
	res, err := q.dataset.Insert(q.fields).Exec()
	if err != nil {
		return 0, errors.Wrap(err, "executing query")
	}
	id, err := res.LastInsertId()
	if err != nil {
		return 0, errors.Wrap(err, "retrieving id")
	}
	q.entityId = id
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return 0, errors.Wrap(err, "running post functions")
		}
	}

	return id, nil
}

func readProjects(tx *goqu.TxDatabase, options ...QueryOpt) ([]Project, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "", "project", nil)
	for _, option := range options {
		if err := option(q); err != nil {
			return []Project{}, errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgBlue)
		log.Println(q.dataset.ToSql())
		color.Unset()
	}
	// Execute query
	rows, err := getRows(tx, q.dataset)
	if err != nil {
		return []Project{}, err
	}
	defer rows.Close()
	projects, err := ScanProjects(rows)
	if err != nil {
		return []Project{}, err
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return []Project{}, errors.Wrap(err, "running post functions")
		}
	}

	// Scan rows to Projects
	return projects, nil
}

func readProject(tx *goqu.TxDatabase, options ...QueryOpt) (Project, bool, error) {
	var exists bool
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "", "project", nil)
	for _, option := range options {
		if err := option(q); err != nil {
			return Project{}, exists, errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgBlue)
		log.Println(q.dataset.ToSql())
		color.Unset()
	}
	// Execute query
	row, err := getRow(tx, q.dataset)
	if err != nil {
		return Project{}, false, err
	}
	ret_project, err := ScanProject(row)
	if err == sql.ErrNoRows {
		return Project{}, false, nil
	} else if err == nil {
		exists = true
	} else {
		return Project{}, false, err
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return Project{}, false, errors.Wrap(err, "running post functions")
		}
	}
	// Scan row to Project
	return ret_project, exists, nil
}

func updateProject(tx *goqu.TxDatabase, projectId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, UpdateOp, "project", projectId)
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if debug && len(q.fields) > 0 {
		color.Set(color.FgYellow)
		log.Println(q.dataset.ToUpdateSql(q.fields))
		color.Unset()
	}
	// Execute query
	if len(q.fields) > 0 {
		if _, err := q.dataset.Update(q.fields).Exec(); err != nil {
			return errors.Wrap(err, "executing query")
		}
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}
	return nil
}

func deleteProject(tx *goqu.TxDatabase, projectId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, DeleteOp, "project", projectId)
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgRed)
		log.Println(q.dataset.ToDeleteSql())
		color.Unset()
	}
	// Execute query
	if _, err := q.dataset.Delete().Exec(); err != nil {
		return errors.Wrap(err, "executing query")
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}

	return nil

}

// ---------- --------------- ----------
// ---------- --------------- ----------
// ---------- regressionModel ----------
// ---------- --------------- ----------
// ---------- --------------- ----------

func createRegressionModel(tx *goqu.TxDatabase, modelId int64, mse, rSquared, meanResidualDeviance float64, options ...QueryOpt) (int64, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, CreateOp, "regression_model", nil)
	// Default insert fields
	regressionModel := goqu.Record{
		"model_id":               modelId,
		"mse":                    mse,
		"r_squared":              rSquared,
		"mean_residual_deviance": meanResidualDeviance,
	}
	q.AddFields(regressionModel)
	for _, option := range options {
		if err := option(q); err != nil {
			return 0, errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgGreen)
		log.Println(q.dataset.ToInsertSql(q.fields))
		color.Unset()
	}
	// Execute query
	res, err := q.dataset.Insert(q.fields).Exec()
	if err != nil {
		return 0, errors.Wrap(err, "executing query")
	}
	id, err := res.LastInsertId()
	if err != nil {
		return 0, errors.Wrap(err, "retrieving id")
	}
	q.entityId = id
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return 0, errors.Wrap(err, "running post functions")
		}
	}

	return id, nil
}

func readRegressionModels(tx *goqu.TxDatabase, options ...QueryOpt) ([]regressionModel, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "", "regression_model", nil)
	for _, option := range options {
		if err := option(q); err != nil {
			return []regressionModel{}, errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgBlue)
		log.Println(q.dataset.ToSql())
		color.Unset()
	}
	// Execute query
	rows, err := getRows(tx, q.dataset)
	if err != nil {
		return []regressionModel{}, err
	}
	defer rows.Close()
	regressionModels, err := ScanRegressionModels(rows)
	if err != nil {
		return []regressionModel{}, err
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return []regressionModel{}, errors.Wrap(err, "running post functions")
		}
	}

	// Scan rows to regressionModels
	return regressionModels, nil
}

func readRegressionModel(tx *goqu.TxDatabase, options ...QueryOpt) (regressionModel, bool, error) {
	var exists bool
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "", "regression_model", nil)
	for _, option := range options {
		if err := option(q); err != nil {
			return regressionModel{}, exists, errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgBlue)
		log.Println(q.dataset.ToSql())
		color.Unset()
	}
	// Execute query
	row, err := getRow(tx, q.dataset)
	if err != nil {
		return regressionModel{}, false, err
	}
	ret_regressionModel, err := ScanRegressionModel(row)
	if err == sql.ErrNoRows {
		return regressionModel{}, false, nil
	} else if err == nil {
		exists = true
	} else {
		return regressionModel{}, false, err
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return regressionModel{}, false, errors.Wrap(err, "running post functions")
		}
	}
	// Scan row to regressionModel
	return ret_regressionModel, exists, nil
}

func updateRegressionModel(tx *goqu.TxDatabase, regressionModelId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, UpdateOp, "regression_model", regressionModelId)
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if debug && len(q.fields) > 0 {
		color.Set(color.FgYellow)
		log.Println(q.dataset.ToUpdateSql(q.fields))
		color.Unset()
	}
	// Execute query
	if len(q.fields) > 0 {
		if _, err := q.dataset.Update(q.fields).Exec(); err != nil {
			return errors.Wrap(err, "executing query")
		}
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}
	return nil
}

func deleteRegressionModel(tx *goqu.TxDatabase, regressionModelId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, DeleteOp, "regression_model", regressionModelId)
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgRed)
		log.Println(q.dataset.ToDeleteSql())
		color.Unset()
	}
	// Execute query
	if _, err := q.dataset.Delete().Exec(); err != nil {
		return errors.Wrap(err, "executing query")
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}

	return nil

}

// ---------- ---- ----------
// ---------- ---- ----------
// ---------- Role ----------
// ---------- ---- ----------
// ---------- ---- ----------

func (ds *Datastore) CreateRole(name string, options ...QueryOpt) (int64, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return 0, errors.Wrap(err, "beginning transaction")
	}

	var id int64
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, CreateOp, "role", nil)
		// Default insert fields
		role := goqu.Record{
			"name":    name,
			"created": time.Now(),
		}
		q.AddFields(role)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if debug {
			color.Set(color.FgGreen)
			log.Println(q.dataset.ToInsertSql(q.fields))
			color.Unset()
		}
		// Execute query
		res, err := q.dataset.Insert(q.fields).Exec()
		if err != nil {
			return errors.Wrap(err, "executing query")
		}
		id, err = res.LastInsertId()
		if err != nil {
			return errors.Wrap(err, "retrieving id")
		}
		q.entityId = id
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}

		return nil
	})

	return id, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) ReadRoles(options ...QueryOpt) ([]Role, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return []Role{}, errors.Wrap(err, "beginning transaction")
	}

	var roles []Role
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, "", "role", nil)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if debug {
			color.Set(color.FgBlue)
			log.Println(q.dataset.ToSql())
			color.Unset()
		}
		// Execute query
		rows, err := getRows(tx, q.dataset)
		if err != nil {
			return err
		}
		defer rows.Close()
		roles, err = ScanRoles(rows)
		if err != nil {
			return err
		}
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}

		return nil
	})

	return roles, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) ReadRole(options ...QueryOpt) (Role, bool, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return Role{}, false, errors.Wrap(err, "beginning transaction")
	}

	var role Role
	var exists bool
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, "", "role", nil)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if debug {
			color.Set(color.FgBlue)
			log.Println(q.dataset.ToSql())
			color.Unset()
		}
		// Execute query
		row, err := getRow(tx, q.dataset)
		if err != nil {
			return err
		}
		role, err = ScanRole(row)
		if err == sql.ErrNoRows {
			return nil
		} else if err == nil {
			exists = true
		}
		if err != nil {
			return err
		}
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}

		return nil
	})

	return role, exists, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) UpdateRole(roleId int64, options ...QueryOpt) error {
	tx, err := ds.db.Begin()
	if err != nil {
		return errors.Wrap(err, "beginning transaction")
	}

	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, UpdateOp, "role", roleId)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if debug && len(q.fields) > 0 {
			color.Set(color.FgYellow)
			log.Println(q.dataset.ToUpdateSql(q.fields))
			color.Unset()
		}
		// Execute query
		if len(q.fields) > 0 {
			if _, err := q.dataset.Update(q.fields).Exec(); err != nil {
				return errors.Wrap(err, "executing query")
			}
		}
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}
		return nil
	})

	return errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) DeleteRole(roleId int64, options ...QueryOpt) error {
	tx, err := ds.db.Begin()
	if err != nil {
		return errors.Wrap(err, "beginning transaction")
	}

	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, DeleteOp, "role", roleId)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if debug {
			color.Set(color.FgRed)
			log.Println(q.dataset.ToDeleteSql())
			color.Unset()
		}
		// Execute query
		if _, err := q.dataset.Delete().Exec(); err != nil {
			return errors.Wrap(err, "executing query")
		}
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}

		return errors.Wrap(deletePrivilege(tx, ByEntityId(q.entityId), ByEntityType(q.entityType)), "deleting privileges")
	})

	return errors.Wrap(err, "committing transaction")
}
func createRole(tx *goqu.TxDatabase, name string, options ...QueryOpt) (int64, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, CreateOp, "role", nil)
	// Default insert fields
	role := goqu.Record{
		"name":    name,
		"created": time.Now(),
	}
	q.AddFields(role)
	for _, option := range options {
		if err := option(q); err != nil {
			return 0, errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgGreen)
		log.Println(q.dataset.ToInsertSql(q.fields))
		color.Unset()
	}
	// Execute query
	res, err := q.dataset.Insert(q.fields).Exec()
	if err != nil {
		return 0, errors.Wrap(err, "executing query")
	}
	id, err := res.LastInsertId()
	if err != nil {
		return 0, errors.Wrap(err, "retrieving id")
	}
	q.entityId = id
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return 0, errors.Wrap(err, "running post functions")
		}
	}

	return id, nil
}

func readRoles(tx *goqu.TxDatabase, options ...QueryOpt) ([]Role, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "", "role", nil)
	for _, option := range options {
		if err := option(q); err != nil {
			return []Role{}, errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgBlue)
		log.Println(q.dataset.ToSql())
		color.Unset()
	}
	// Execute query
	rows, err := getRows(tx, q.dataset)
	if err != nil {
		return []Role{}, err
	}
	defer rows.Close()
	roles, err := ScanRoles(rows)
	if err != nil {
		return []Role{}, err
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return []Role{}, errors.Wrap(err, "running post functions")
		}
	}

	// Scan rows to Roles
	return roles, nil
}

func readRole(tx *goqu.TxDatabase, options ...QueryOpt) (Role, bool, error) {
	var exists bool
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "", "role", nil)
	for _, option := range options {
		if err := option(q); err != nil {
			return Role{}, exists, errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgBlue)
		log.Println(q.dataset.ToSql())
		color.Unset()
	}
	// Execute query
	row, err := getRow(tx, q.dataset)
	if err != nil {
		return Role{}, false, err
	}
	ret_role, err := ScanRole(row)
	if err == sql.ErrNoRows {
		return Role{}, false, nil
	} else if err == nil {
		exists = true
	} else {
		return Role{}, false, err
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return Role{}, false, errors.Wrap(err, "running post functions")
		}
	}
	// Scan row to Role
	return ret_role, exists, nil
}

func updateRole(tx *goqu.TxDatabase, roleId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, UpdateOp, "role", roleId)
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if debug && len(q.fields) > 0 {
		color.Set(color.FgYellow)
		log.Println(q.dataset.ToUpdateSql(q.fields))
		color.Unset()
	}
	// Execute query
	if len(q.fields) > 0 {
		if _, err := q.dataset.Update(q.fields).Exec(); err != nil {
			return errors.Wrap(err, "executing query")
		}
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}
	return nil
}

func deleteRole(tx *goqu.TxDatabase, roleId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, DeleteOp, "role", roleId)
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgRed)
		log.Println(q.dataset.ToDeleteSql())
		color.Unset()
	}
	// Execute query
	if _, err := q.dataset.Delete().Exec(); err != nil {
		return errors.Wrap(err, "executing query")
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}

	return nil

}

// ---------- -------------- ----------
// ---------- -------------- ----------
// ---------- rolePermission ----------
// ---------- -------------- ----------
// ---------- -------------- ----------

func createRolePermission(tx *goqu.TxDatabase, roleId, permissionId int64, options ...QueryOpt) (int64, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, CreateOp, "role_permission", nil)
	// Default insert fields
	rolePermission := goqu.Record{
		"role_id":       roleId,
		"permission_id": permissionId,
	}
	q.AddFields(rolePermission)
	for _, option := range options {
		if err := option(q); err != nil {
			return 0, errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgGreen)
		log.Println(q.dataset.ToInsertSql(q.fields))
		color.Unset()
	}
	// Execute query
	res, err := q.dataset.Insert(q.fields).Exec()
	if err != nil {
		return 0, errors.Wrap(err, "executing query")
	}
	id, err := res.LastInsertId()
	if err != nil {
		return 0, errors.Wrap(err, "retrieving id")
	}
	q.entityId = id
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return 0, errors.Wrap(err, "running post functions")
		}
	}

	return id, nil
}

func readRolePermissions(tx *goqu.TxDatabase, options ...QueryOpt) ([]rolePermission, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "", "role_permission", nil)
	for _, option := range options {
		if err := option(q); err != nil {
			return []rolePermission{}, errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgBlue)
		log.Println(q.dataset.ToSql())
		color.Unset()
	}
	// Execute query
	rows, err := getRows(tx, q.dataset)
	if err != nil {
		return []rolePermission{}, err
	}
	defer rows.Close()
	rolePermissions, err := ScanRolePermissions(rows)
	if err != nil {
		return []rolePermission{}, err
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return []rolePermission{}, errors.Wrap(err, "running post functions")
		}
	}

	// Scan rows to rolePermissions
	return rolePermissions, nil
}

func readRolePermission(tx *goqu.TxDatabase, options ...QueryOpt) (rolePermission, bool, error) {
	var exists bool
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "", "role_permission", nil)
	for _, option := range options {
		if err := option(q); err != nil {
			return rolePermission{}, exists, errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgBlue)
		log.Println(q.dataset.ToSql())
		color.Unset()
	}
	// Execute query
	row, err := getRow(tx, q.dataset)
	if err != nil {
		return rolePermission{}, false, err
	}
	ret_rolePermission, err := ScanRolePermission(row)
	if err == sql.ErrNoRows {
		return rolePermission{}, false, nil
	} else if err == nil {
		exists = true
	} else {
		return rolePermission{}, false, err
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return rolePermission{}, false, errors.Wrap(err, "running post functions")
		}
	}
	// Scan row to rolePermission
	return ret_rolePermission, exists, nil
}

func updateRolePermission(tx *goqu.TxDatabase, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, UpdateOp, "role_permission", nil)
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if debug && len(q.fields) > 0 {
		color.Set(color.FgYellow)
		log.Println(q.dataset.ToUpdateSql(q.fields))
		color.Unset()
	}
	// Execute query
	if len(q.fields) > 0 {
		if _, err := q.dataset.Update(q.fields).Exec(); err != nil {
			return errors.Wrap(err, "executing query")
		}
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}
	return nil
}

func deleteRolePermission(tx *goqu.TxDatabase, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, DeleteOp, "role_permission", nil)
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgRed)
		log.Println(q.dataset.ToDeleteSql())
		color.Unset()
	}
	// Execute query
	if _, err := q.dataset.Delete().Exec(); err != nil {
		return errors.Wrap(err, "executing query")
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}

	return nil

}

// ---------- ----- ----------
// ---------- ----- ----------
// ---------- state ----------
// ---------- ----- ----------
// ---------- ----- ----------

func createState(tx *goqu.TxDatabase, name string, options ...QueryOpt) (int64, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, CreateOp, "state", nil)
	// Default insert fields
	state := goqu.Record{
		"name": name,
	}
	q.AddFields(state)
	for _, option := range options {
		if err := option(q); err != nil {
			return 0, errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgGreen)
		log.Println(q.dataset.ToInsertSql(q.fields))
		color.Unset()
	}
	// Execute query
	res, err := q.dataset.Insert(q.fields).Exec()
	if err != nil {
		return 0, errors.Wrap(err, "executing query")
	}
	id, err := res.LastInsertId()
	if err != nil {
		return 0, errors.Wrap(err, "retrieving id")
	}
	q.entityId = id
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return 0, errors.Wrap(err, "running post functions")
		}
	}

	return id, nil
}

func readStates(tx *goqu.TxDatabase, options ...QueryOpt) ([]state, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "", "state", nil)
	for _, option := range options {
		if err := option(q); err != nil {
			return []state{}, errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgBlue)
		log.Println(q.dataset.ToSql())
		color.Unset()
	}
	// Execute query
	rows, err := getRows(tx, q.dataset)
	if err != nil {
		return []state{}, err
	}
	defer rows.Close()
	states, err := ScanStates(rows)
	if err != nil {
		return []state{}, err
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return []state{}, errors.Wrap(err, "running post functions")
		}
	}

	// Scan rows to states
	return states, nil
}

func readState(tx *goqu.TxDatabase, options ...QueryOpt) (state, bool, error) {
	var exists bool
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "", "state", nil)
	for _, option := range options {
		if err := option(q); err != nil {
			return state{}, exists, errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgBlue)
		log.Println(q.dataset.ToSql())
		color.Unset()
	}
	// Execute query
	row, err := getRow(tx, q.dataset)
	if err != nil {
		return state{}, false, err
	}
	ret_state, err := ScanState(row)
	if err == sql.ErrNoRows {
		return state{}, false, nil
	} else if err == nil {
		exists = true
	} else {
		return state{}, false, err
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return state{}, false, errors.Wrap(err, "running post functions")
		}
	}
	// Scan row to state
	return ret_state, exists, nil
}

func updateState(tx *goqu.TxDatabase, stateId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, UpdateOp, "state", stateId)
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if debug && len(q.fields) > 0 {
		color.Set(color.FgYellow)
		log.Println(q.dataset.ToUpdateSql(q.fields))
		color.Unset()
	}
	// Execute query
	if len(q.fields) > 0 {
		if _, err := q.dataset.Update(q.fields).Exec(); err != nil {
			return errors.Wrap(err, "executing query")
		}
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}
	return nil
}

func deleteState(tx *goqu.TxDatabase, stateId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, DeleteOp, "state", stateId)
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgRed)
		log.Println(q.dataset.ToDeleteSql())
		color.Unset()
	}
	// Execute query
	if _, err := q.dataset.Delete().Exec(); err != nil {
		return errors.Wrap(err, "executing query")
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}

	return nil

}

// ---------- ------- ----------
// ---------- ------- ----------
// ---------- Service ----------
// ---------- ------- ----------
// ---------- ------- ----------

func (ds *Datastore) CreateService(projectId, modelId int64, name string, options ...QueryOpt) (int64, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return 0, errors.Wrap(err, "beginning transaction")
	}

	var id int64
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, CreateOp, "service", nil)
		// Default insert fields
		service := goqu.Record{
			"project_id": projectId,
			"model_id":   modelId,
			"name":       name,
			"state":      States.Starting,
			"created":    time.Now(),
		}
		q.AddFields(service)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if debug {
			color.Set(color.FgGreen)
			log.Println(q.dataset.ToInsertSql(q.fields))
			color.Unset()
		}
		// Execute query
		res, err := q.dataset.Insert(q.fields).Exec()
		if err != nil {
			return errors.Wrap(err, "executing query")
		}
		id, err = res.LastInsertId()
		if err != nil {
			return errors.Wrap(err, "retrieving id")
		}
		q.entityId = id
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}

		return nil
	})

	return id, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) ReadServices(options ...QueryOpt) ([]Service, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return []Service{}, errors.Wrap(err, "beginning transaction")
	}

	var services []Service
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, "", "service", nil)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if debug {
			color.Set(color.FgBlue)
			log.Println(q.dataset.ToSql())
			color.Unset()
		}
		// Execute query
		rows, err := getRows(tx, q.dataset)
		if err != nil {
			return err
		}
		defer rows.Close()
		services, err = ScanServices(rows)
		if err != nil {
			return err
		}
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}

		return nil
	})

	return services, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) ReadService(options ...QueryOpt) (Service, bool, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return Service{}, false, errors.Wrap(err, "beginning transaction")
	}

	var service Service
	var exists bool
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, "", "service", nil)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if debug {
			color.Set(color.FgBlue)
			log.Println(q.dataset.ToSql())
			color.Unset()
		}
		// Execute query
		row, err := getRow(tx, q.dataset)
		if err != nil {
			return err
		}
		service, err = ScanService(row)
		if err == sql.ErrNoRows {
			return nil
		} else if err == nil {
			exists = true
		}
		if err != nil {
			return err
		}
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}

		return nil
	})

	return service, exists, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) UpdateService(serviceId int64, options ...QueryOpt) error {
	tx, err := ds.db.Begin()
	if err != nil {
		return errors.Wrap(err, "beginning transaction")
	}

	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, UpdateOp, "service", serviceId)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if debug && len(q.fields) > 0 {
			color.Set(color.FgYellow)
			log.Println(q.dataset.ToUpdateSql(q.fields))
			color.Unset()
		}
		// Execute query
		if len(q.fields) > 0 {
			if _, err := q.dataset.Update(q.fields).Exec(); err != nil {
				return errors.Wrap(err, "executing query")
			}
		}
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}
		return nil
	})

	return errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) DeleteService(serviceId int64, options ...QueryOpt) error {
	tx, err := ds.db.Begin()
	if err != nil {
		return errors.Wrap(err, "beginning transaction")
	}

	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, DeleteOp, "service", serviceId)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if debug {
			color.Set(color.FgRed)
			log.Println(q.dataset.ToDeleteSql())
			color.Unset()
		}
		// Execute query
		if _, err := q.dataset.Delete().Exec(); err != nil {
			return errors.Wrap(err, "executing query")
		}
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}

		return errors.Wrap(deletePrivilege(tx, ByEntityId(q.entityId), ByEntityType(q.entityType)), "deleting privileges")
	})

	return errors.Wrap(err, "committing transaction")
}
func createService(tx *goqu.TxDatabase, projectId, modelId int64, name string, options ...QueryOpt) (int64, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, CreateOp, "service", nil)
	// Default insert fields
	service := goqu.Record{
		"project_id": projectId,
		"model_id":   modelId,
		"name":       name,
		"state":      States.Starting,
		"created":    time.Now(),
	}
	q.AddFields(service)
	for _, option := range options {
		if err := option(q); err != nil {
			return 0, errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgGreen)
		log.Println(q.dataset.ToInsertSql(q.fields))
		color.Unset()
	}
	// Execute query
	res, err := q.dataset.Insert(q.fields).Exec()
	if err != nil {
		return 0, errors.Wrap(err, "executing query")
	}
	id, err := res.LastInsertId()
	if err != nil {
		return 0, errors.Wrap(err, "retrieving id")
	}
	q.entityId = id
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return 0, errors.Wrap(err, "running post functions")
		}
	}

	return id, nil
}

func readServices(tx *goqu.TxDatabase, options ...QueryOpt) ([]Service, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "", "service", nil)
	for _, option := range options {
		if err := option(q); err != nil {
			return []Service{}, errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgBlue)
		log.Println(q.dataset.ToSql())
		color.Unset()
	}
	// Execute query
	rows, err := getRows(tx, q.dataset)
	if err != nil {
		return []Service{}, err
	}
	defer rows.Close()
	services, err := ScanServices(rows)
	if err != nil {
		return []Service{}, err
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return []Service{}, errors.Wrap(err, "running post functions")
		}
	}

	// Scan rows to Services
	return services, nil
}

func readService(tx *goqu.TxDatabase, options ...QueryOpt) (Service, bool, error) {
	var exists bool
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "", "service", nil)
	for _, option := range options {
		if err := option(q); err != nil {
			return Service{}, exists, errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgBlue)
		log.Println(q.dataset.ToSql())
		color.Unset()
	}
	// Execute query
	row, err := getRow(tx, q.dataset)
	if err != nil {
		return Service{}, false, err
	}
	ret_service, err := ScanService(row)
	if err == sql.ErrNoRows {
		return Service{}, false, nil
	} else if err == nil {
		exists = true
	} else {
		return Service{}, false, err
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return Service{}, false, errors.Wrap(err, "running post functions")
		}
	}
	// Scan row to Service
	return ret_service, exists, nil
}

func updateService(tx *goqu.TxDatabase, serviceId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, UpdateOp, "service", serviceId)
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if debug && len(q.fields) > 0 {
		color.Set(color.FgYellow)
		log.Println(q.dataset.ToUpdateSql(q.fields))
		color.Unset()
	}
	// Execute query
	if len(q.fields) > 0 {
		if _, err := q.dataset.Update(q.fields).Exec(); err != nil {
			return errors.Wrap(err, "executing query")
		}
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}
	return nil
}

func deleteService(tx *goqu.TxDatabase, serviceId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, DeleteOp, "service", serviceId)
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgRed)
		log.Println(q.dataset.ToDeleteSql())
		color.Unset()
	}
	// Execute query
	if _, err := q.dataset.Delete().Exec(); err != nil {
		return errors.Wrap(err, "executing query")
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}

	return nil

}

// ---------- --------- ----------
// ---------- --------- ----------
// ---------- Workgroup ----------
// ---------- --------- ----------
// ---------- --------- ----------

func (ds *Datastore) CreateWorkgroup(typ, name string, options ...QueryOpt) (int64, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return 0, errors.Wrap(err, "beginning transaction")
	}

	var id int64
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, CreateOp, "workgroup", nil)
		// Default insert fields
		workgroup := goqu.Record{
			"type":    typ,
			"name":    name,
			"created": time.Now(),
		}
		q.AddFields(workgroup)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if debug {
			color.Set(color.FgGreen)
			log.Println(q.dataset.ToInsertSql(q.fields))
			color.Unset()
		}
		// Execute query
		res, err := q.dataset.Insert(q.fields).Exec()
		if err != nil {
			return errors.Wrap(err, "executing query")
		}
		id, err = res.LastInsertId()
		if err != nil {
			return errors.Wrap(err, "retrieving id")
		}
		q.entityId = id
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}

		return nil
	})

	return id, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) ReadWorkgroups(options ...QueryOpt) ([]Workgroup, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return []Workgroup{}, errors.Wrap(err, "beginning transaction")
	}

	var workgroups []Workgroup
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, "", "workgroup", nil)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if debug {
			color.Set(color.FgBlue)
			log.Println(q.dataset.ToSql())
			color.Unset()
		}
		// Execute query
		rows, err := getRows(tx, q.dataset)
		if err != nil {
			return err
		}
		defer rows.Close()
		workgroups, err = ScanWorkgroups(rows)
		if err != nil {
			return err
		}
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}

		return nil
	})

	return workgroups, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) ReadWorkgroup(options ...QueryOpt) (Workgroup, bool, error) {
	tx, err := ds.db.Begin()
	if err != nil {
		return Workgroup{}, false, errors.Wrap(err, "beginning transaction")
	}

	var workgroup Workgroup
	var exists bool
	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, "", "workgroup", nil)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if debug {
			color.Set(color.FgBlue)
			log.Println(q.dataset.ToSql())
			color.Unset()
		}
		// Execute query
		row, err := getRow(tx, q.dataset)
		if err != nil {
			return err
		}
		workgroup, err = ScanWorkgroup(row)
		if err == sql.ErrNoRows {
			return nil
		} else if err == nil {
			exists = true
		}
		if err != nil {
			return err
		}
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}

		return nil
	})

	return workgroup, exists, errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) UpdateWorkgroup(workgroupId int64, options ...QueryOpt) error {
	tx, err := ds.db.Begin()
	if err != nil {
		return errors.Wrap(err, "beginning transaction")
	}

	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, UpdateOp, "workgroup", workgroupId)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if debug && len(q.fields) > 0 {
			color.Set(color.FgYellow)
			log.Println(q.dataset.ToUpdateSql(q.fields))
			color.Unset()
		}
		// Execute query
		if len(q.fields) > 0 {
			if _, err := q.dataset.Update(q.fields).Exec(); err != nil {
				return errors.Wrap(err, "executing query")
			}
		}
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}
		return nil
	})

	return errors.Wrap(err, "committing transaction")
}

func (ds *Datastore) DeleteWorkgroup(workgroupId int64, options ...QueryOpt) error {
	tx, err := ds.db.Begin()
	if err != nil {
		return errors.Wrap(err, "beginning transaction")
	}

	err = tx.Wrap(func() error {
		// Setup query with optional parameters
		q := NewQueryConfig(ds, tx, DeleteOp, "workgroup", workgroupId)
		for _, option := range options {
			if err := option(q); err != nil {
				return errors.Wrap(err, "setting up query options")
			}
		}
		if debug {
			color.Set(color.FgRed)
			log.Println(q.dataset.ToDeleteSql())
			color.Unset()
		}
		// Execute query
		if _, err := q.dataset.Delete().Exec(); err != nil {
			return errors.Wrap(err, "executing query")
		}
		for _, post := range q.postFunc {
			if err := post(q); err != nil {
				return errors.Wrap(err, "running post functions")
			}
		}

		return errors.Wrap(deletePrivilege(tx, ByEntityId(q.entityId), ByEntityType(q.entityType)), "deleting privileges")
	})

	return errors.Wrap(err, "committing transaction")
}
func createWorkgroup(tx *goqu.TxDatabase, typ, name string, options ...QueryOpt) (int64, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, CreateOp, "workgroup", nil)
	// Default insert fields
	workgroup := goqu.Record{
		"type":    typ,
		"name":    name,
		"created": time.Now(),
	}
	q.AddFields(workgroup)
	for _, option := range options {
		if err := option(q); err != nil {
			return 0, errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgGreen)
		log.Println(q.dataset.ToInsertSql(q.fields))
		color.Unset()
	}
	// Execute query
	res, err := q.dataset.Insert(q.fields).Exec()
	if err != nil {
		return 0, errors.Wrap(err, "executing query")
	}
	id, err := res.LastInsertId()
	if err != nil {
		return 0, errors.Wrap(err, "retrieving id")
	}
	q.entityId = id
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return 0, errors.Wrap(err, "running post functions")
		}
	}

	return id, nil
}

func readWorkgroups(tx *goqu.TxDatabase, options ...QueryOpt) ([]Workgroup, error) {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "", "workgroup", nil)
	for _, option := range options {
		if err := option(q); err != nil {
			return []Workgroup{}, errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgBlue)
		log.Println(q.dataset.ToSql())
		color.Unset()
	}
	// Execute query
	rows, err := getRows(tx, q.dataset)
	if err != nil {
		return []Workgroup{}, err
	}
	defer rows.Close()
	workgroups, err := ScanWorkgroups(rows)
	if err != nil {
		return []Workgroup{}, err
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return []Workgroup{}, errors.Wrap(err, "running post functions")
		}
	}

	// Scan rows to Workgroups
	return workgroups, nil
}

func readWorkgroup(tx *goqu.TxDatabase, options ...QueryOpt) (Workgroup, bool, error) {
	var exists bool
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, "", "workgroup", nil)
	for _, option := range options {
		if err := option(q); err != nil {
			return Workgroup{}, exists, errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgBlue)
		log.Println(q.dataset.ToSql())
		color.Unset()
	}
	// Execute query
	row, err := getRow(tx, q.dataset)
	if err != nil {
		return Workgroup{}, false, err
	}
	ret_workgroup, err := ScanWorkgroup(row)
	if err == sql.ErrNoRows {
		return Workgroup{}, false, nil
	} else if err == nil {
		exists = true
	} else {
		return Workgroup{}, false, err
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return Workgroup{}, false, errors.Wrap(err, "running post functions")
		}
	}
	// Scan row to Workgroup
	return ret_workgroup, exists, nil
}

func updateWorkgroup(tx *goqu.TxDatabase, workgroupId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, UpdateOp, "workgroup", workgroupId)
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if debug && len(q.fields) > 0 {
		color.Set(color.FgYellow)
		log.Println(q.dataset.ToUpdateSql(q.fields))
		color.Unset()
	}
	// Execute query
	if len(q.fields) > 0 {
		if _, err := q.dataset.Update(q.fields).Exec(); err != nil {
			return errors.Wrap(err, "executing query")
		}
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}
	return nil
}

func deleteWorkgroup(tx *goqu.TxDatabase, workgroupId int64, options ...QueryOpt) error {
	// Setup query with optional parameters
	q := NewQueryConfig(nil, tx, DeleteOp, "workgroup", workgroupId)
	for _, option := range options {
		if err := option(q); err != nil {
			return errors.Wrap(err, "setting up query options")
		}
	}
	if debug {
		color.Set(color.FgRed)
		log.Println(q.dataset.ToDeleteSql())
		color.Unset()
	}
	// Execute query
	if _, err := q.dataset.Delete().Exec(); err != nil {
		return errors.Wrap(err, "executing query")
	}
	for _, post := range q.postFunc {
		if err := post(q); err != nil {
			return errors.Wrap(err, "running post functions")
		}
	}

	return nil

}
